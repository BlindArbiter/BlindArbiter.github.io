[{"title":"游戏编程模式-设计模式","path":"/2024/10/22/241021 游戏编程模式-设计模式 /","content":"最近在学 一些建议？ 抽象和解耦让扩展代码更快更容易，但除非确信需要灵活性，否则不要在这上面浪费时间。 在整个开发周期中为性能考虑并做好设计，但是尽可能推迟那些底层的，基于假设的优化，那会锁死代码。 快速地探索游戏的设计空间，但不要跑得太快，在身后留下烂摊子。毕竟你总得回来打扫。 如果打算抛弃这段代码，就不要尝试将其写完美。摇滚明星将旅店房间弄得一团糟，因为他们知道明天就走人了。 但最重要的是，如果你想要做出让人享受的东西，那就享受做它的过程。 设计模式命令模式将请求或操作封装成一个命令对象，使得客户端可通过调用命令对象来执行请求命令是具现化的方法调用，命令模式是一种回调的面向对象实现 优点 解耦调用者和接收者：调用者只需持有命令对象，而不需要知道具体的操作细节 易于扩展：容易新增命令，而不需要修改现有的代码 支持撤销和重做、组合命令 缺点 类的数量增加：每个具体命令类都需要单独定义，系统更复杂 命令的参数化：复杂的操作，命令对象需要传递大量参数 享元模式核心思想是将对象的共享部分抽取出来，将多个对象中的共有状态存储在一个共享对象中，而将各自独有的状态保存在对象外部。 一些特点： 唯一需要硬件支持的模式， 注重效率，能减少内存消耗，提高性能 享元对象一般是不可变的 观察者模式使得多个观察者对象在被观察的对象状态发生变化时自动收到通知并更新自己适用于不相关模块之间的通信问题，不适用于专注于一个特性或层面的单一代码块/模块内 设计观察者模式，最好基于函数而不是基于类，注册成员函数指针为观察者，而不是Observer接口实例 存在的问题：技术/可维护性 难的是要记得销毁被观察者和观察者 即使有GC，但 失效观察者 问题依旧可能存在，即被观察者保留了对观察者的引用，最终有对象僵死在内存中，也就是内存泄漏 原型模式使用现有实例来创建特定种类的对象，通过拷贝创建新对象 优点：允许动态地创建新的对象实例，避免重复的初始化操作缺点：克隆方法实现可能需要考虑深拷贝与浅拷贝，尤其是在对象包含复杂结构或外部资源时 原型语言范式： self语言 原型继承：所有对象都是基于现有对象复制和修改来的 更像是面向对象的语言，没有类概念，所有的数据结构都是对象、控制结构和方法调用都是对象调用 动态绑定、动态继承：实际支持多个父类，父类只是一个特殊的字段，可以继承父类或者在运行的时候修改它们 JavaScript是基于原型的语言 跟 self 不同的是除去了基于原型语言的核心操作“克隆” 状态存储在实例中 行为通过原型的委托被存储在独立的对象中，代表了一系列特定类型对象的共享方法 数据模型构建原型： 代码只是驱动游戏的“引擎”，游戏是完全由数据定义的 游戏数据达到一定规模时，可以考虑使用原型和委托重用数据 单例模式核心：实例全局化，确保一个类只有一个实例，且提供一个全局访问点来访问唯一实例 优点： 访问便利 不使用就不会创建实例，运行时初始化，延迟初始化 可继承单例 缺点： 是一个全局变量，促进耦合，对并发不友好，容易死锁 使用单例的解决方案 重新评估是否需要类：单例常用于“管理器”类，但实际中可以避免单例，例如直接将管理器逻辑直接移到类本身，让对象自我管理 将类限制为单一实例，用断言函数assert 为实例提供便捷的访问方式 依赖注入：做参数传给函数，但存在对象不属于方法函数的签名的情况 处理横切关注点：某些依赖在多个地方需要使用，面向切面编程处理这类关注点，而不必每次传参 从基类中获得：让子类通过继承获取共用依赖 通过其他全局对象访问：将需要的依赖集中在一个核心对象中，避免创建多个单例 通过服务定位器访问：定义一个类专门给对象做全局访问 状态模式允许对象在其内部改变自身行为 枚举和分支：一系列标记成员变量只能存在一个true时定义Enum 有限状态机（FSMs）：可看作最简单的的图灵机，不过不是图灵完备的 拥有一组有限状态集合，可在状态间切换，同一时刻只能处于一种状态 根据外部输入或事件触发状态间转换 状态模式应用： 定义状态接口 为每个状态定义类 状态委托 三种主对象委托给另外的附属对象的模式行为区别 状态模式——状态委托通过改变主对象代理的对象来改变主对象的行为 策略模式将主类和部分行为解耦 类型对象模式使多个对象通过共享相同类型对象的引用来表现相似性 适用场景： 一个游戏实体的行为基于它的内部状态而改变 状态可被严格划分为相对数目较少的不相干项目 实体响应一系列输入或事件 注意： 为状态实例动态分配空间时，需要考虑碎片化问题，用静态状态的话就不会占用太多的CPU和内存资源 其他状态机 并发状态机 可同时拥有多个状态，允许多个状态机并发处理输入 是多个有限状态机的组合，彼此独立但可能会相互影响 层次状态机 将相似行为状态分组，形成层级结构，即状态可以有父状态 可以减少状态数量并简化状态转换 下推自动机 状态栈，可存储历史信息，不适合并行处理 其他一些需要注意的 面向对象就是让对象自己管理自己 两种易出错的代码 有复杂的分支 随时间可变的状态 继承是一种强大的代码重用方式，也可能使代码变得耦合","categories":["游戏编程模式"]},{"title":"Cisco相关2","path":"/2024/10/15/241015 Cisco相关2/","content":"CCNP相关 保存配置因为关闭设备的话设备会被重置，原先配置的命令会丢失，用这个命令可以保存配置。 12write memory# 缩写 wr 虚拟接口Loopback 接口 是一种逻辑IP接口，常用于测试、路由标识和逻辑连接。Loopback接口始终处于启用状态，除非被显式地关闭 12int loopback [接口编号]ip address [ip地址] [子网掩码] Null0 接口 用于丢弃数据包的“黑洞”接口，主要应用于控制无效流量作用：防止路由环路、减少无效流量和增强网络安全性 12int [接口]ip summary-address eigrp [eigrp编号] [ip地址] [子网掩码] DCEDCE 是指在数据通信中提供时钟信号和管理数据传输的设备。DCE设备通常负责链路的时钟生成和同步，它提供时钟信号来控制链路两端的通信速率，确保数据能够按时并同步地传输。 12int se0/0/0 # 选择要配置的端口clock rate 64000 # 在DCE接口上设置时钟频率 配置EIGRP12345678910-- 创建 Eigrp 协议route eigrp 100network [宣告本地网段]eigrp router-id 1.1.1.1-- 手动汇总 EIGRP 路由int loopback 0ip summary-address eigrp 100 172.16.0.0 255.255.0.0-- 配完可以在路由表里看到下面这条-- D 172.16.0.0/16 is a summary, 00:07:14, Null0 汇总路由的作用： 减少路由表大小 降低路由更新的带宽消耗 EIGRP for IPv6传统 EIGRP 的拓展，用于在 IPv6 网络中进行路由选择 12345678Router(config)# ipv6 unicast-routing # 启动 IPv6 路由转发Router(config)# ipv6 router eigrp 1 # 启动 EIGRP for IPv6，AS号为1Router(config-rtr)# eigrp router-id 1.1.1.1 # 配置路由器 idRouter(config-rtr)# no shutdown # 启动 EIGRP-- 在接口上启用 EIGRP IPv6interface loopback 0ipv6 eigrp 1 EIGRP-MD5认证配置12345678910111213-- 创建密钥链-- 配置密钥编号和密钥字符串-- 建议在配置中涉及的所有路由器上使用相同的密钥号和密钥字符串Route(config)# key chain [密钥链名字]Route(config-keychain)# key 1Route(config-keychain-key)# key-string cisco-- 配置认证-- 指定接口，启用Eigrp消息认证通过md5哈希散列算法认证，指定应该用于认证的密钥链Route(config)# int fa0/0Route(config-subif)# ip authentication mode eigrp 10 md5Route(config-subif)# ip authentication key-chain eigrp 100 [密钥链名字] EIGRP的非等价负载均衡非等价负载平衡是指在 EIGRP 中，允许路由器在到达同一个目标网络时，同时使用多条路径进行数据转发，即使这些路径的度量值（Metric）不相等。 默认情况下，EIGRP 只会使用度量值完全相等的路径（等价负载平衡）。但通过启用非等价负载平衡，EIGRP 可以灵活利用路径资源，进一步优化网络性能。 原理： 可行条件（FC） 路径的广告距离（AD）必须小于当前路径的可用距离（FD）。满足此条件后，这条路径会被加入拓扑表，并标记为可行后继者（FS）。 负载分配 在启用非等价负载平衡后，EIGRP 会按照路径度量值的比例分配流量： 流量多的路径：度量值较低（开销小）的路径。 流量少的路径：度量值较高（开销大）的路径。 123456789# 1、配置 R2 的 EIGRP 的度量，确保 R2 成为 R1 的可行后继者R2(config)#int fa0/0R2(config-if)#bandwidth [带宽]R2(config-if)#delay 10# 调整xxx的值，确保R2到达目标网络的FD变小。此值在R1上显示为AD# 2、配置 R1 的 EIGRP 的 variance 值R1(config)#router eigrp 100R1(config-router)#variance 2 --倍数，表示允许的路径开销是当前最佳路径的倍数以内。 12345678910111213# 查看 Eigrp 拓扑表命令R1#show ip eigrp topology all-links………P 192.168.1.0/24, 1 successors, FD is 156160, serno 6 via 172.16.1.10 (156160/128256), FastEthernet0/0 via 172.16.1.2 (2300416/130816), Serial1/1R1#show ip route………C 172.16.1.0 is directly connected, Serial1/1D 192.168.1.0/24 [90/156160] via 172.16.1.10, 00:00:01, FastEthernet0/0 [90/2300416] via 172.16.1.2, 00:00:01, Serial1/1 在Eigrp中，当到达一个目标网络同时存在多条路径，若路径度量值相等则都会显示，不相等时，路由表中仅会显示最优路径 在配置了正确的 variance 后，我们能在路由表中看到不等价均衡负载的多条路由 OSPF配置默认情况下，Loopback 接口被宣传为带有 /32 掩码的主机路由。OSPF 会将 Loopback 接口作为一个“主机”接口进行传播,advertise他们的网络线路,环回接口网络类型必须改变点的点。在此步骤中，您将将环回接口标记为点对点 1234567891011121314R2(config)# interface loopback 100R2(config-if)# ip ospf network point-to-point # 为 Loopback0 接口配置 point-to-point 网络类型R2(config)# router ospf 1R2(config-router)# network 172.16.23.0 0.0.0.255 area 0# OSPF 中 对不同区域的路由进行汇总R3(config)# router ospf 1R3(config-router)# area 20 range 192.168.8.0 255.255.252.0R3# show ip route ospf # 验证汇总结果# 被动接口 # 禁止 OSPF 邻接建立，但路由信息仍然交换R2(config)#router ospf 1R2(config-router)#passive-interface g0/0 OSPFv3 配置OSPF 协议的第三个版本，专门为支持 IPv6 地址而设计 123456789101112-- 启用 OSPFv3R2(config)# ipv6 unicast-routing # 启用IPv6路由R2(config)# ipv6 router ospf 1 # 启动OSPFv3进程，进程号为1R2(config-rtr)# router-id 2.2.2.2 # 配置OSPFv3路由器ID-- 在接口上启用 OSPFv3R2(config)# int loopback 0R2(config-if)# ipv6 ospf 1 area 0 # 将接口加入区域0-- 检测配置命令show ipv6 ospf neighbor # 查看 OSPFv3 邻居关系show ipv6 route ospf # 查看 OSPFv3 路由表 RIP1234R2(config)# router ripR2(config-router)#version 2R2(config-router)# no auto-summaryR2(config-router)# network 12.1.0.0 重分发目的是在两个不同的路由协议之间共享路由信息 OSPFv3 和 EIGRP IPv6 之间的重分发 1234567R2(config)# ipv6 router ospf 1R2(config-router)# redistribute eigrp 1R2(config)# ipv6 router eigrp 1R2(config-rtr)# redistribute ospf 1 metric 1500 100 255 1 1500R2(config-rtr)# redistribute connected OSPF 和 RIP 重分发 123456R2(config)#router ospf 1R2(config-router)#redistribute rip metric 200 subnets# 将OSPF网络路由重发布到RIP中。并指定其度量跳数为：10R2(config)#router ripR2(config-router)#redistribute ospf 1 metric 10 OSPF 和 静态路由 123# 在R2上没有静态路由信息，默认情况下，OSPF路由器不会生成默认路由并将其注入到OSPF路由选择域中# 要让OSPF生成默认路由需配置下面的命令R2(config-router)#default-information originate EIGRP 和 静态路由 1redistribute static subnets CEF (Cisco Express Forwarding)Cisco 路由器的一项高性能数据包转发技术，旨在提高路由器的数据包转发效率。CEF 基于前向信息库 (FIB) 和邻接表，采用预先计算好的路径信息来加速数据包的转发过程，减少路由器的 CPU 负载，提高整个网络的性能，特别是在大型网络环境下。 12345678# 启用 CEFRouter(config)# ip cefRouter(config)# ipv6 cef# 禁用 CEFRouter(config)# no ip cefRouter(config)# no ipv6 cef# 检查命令show ip cef Tunnel IPv612345R3(config)# interface Tunnel 0R3(config-if)# ipv6 address 2001:db8:3::1/64R3(config-if)# tunnel source GigabitEthernet0/0 --配置外部物理接口R3(config-if)# tunnel destination [R4 的公网地址]R3(config-if)# tunnel mode ipv6ip --配置隧道的传输类型为 ipv6ip NAT 1234ip nat inside source static 192.168.3.3 202.1.1.30 --将内网ip一对一映射到外网ipaccess-list 1 permit 192.168.3.0 0.0.0.255 ip nat pool p1 202.1.1.17 202.1.1.29 netmask 255.255.255.240 --nat地址池，为内网设备提供外网ipip nat inside source list 1 pool p1 overload 其他 Ctrl + Shift + 6 可以强制跳出一些正在运行的命令","tags":["cisco","ccnp"],"categories":["编程相关"]},{"title":"Roblox - 制作插件","path":"/2024/05/16/240516 Roblox-制作插件/","content":"第一次尝试制作插件 2024 年 5 月 16 日第一次做 Roblox 插件，写点零零散散的2024 年 11 月 1 日现在做的插件总有种写期末小学期的既视感，也算是完整的小项目（？ 插件使用和显示 插件按钮 在插件导航栏创建按钮，点击按钮实现插件功能或者打开插件窗口 1234567local toorbar = plugin:CreateToolbar(&quot;在插件导航栏显示的分区名&quot;)local Button = toorbar:CreateButton(&quot;插件名&quot;,&quot;插件描述&quot;, &quot;rbxassetid://图标Id&quot;)Button.Click:Connect(function()\t--打开插件UI\t--插件功能end) 创建编辑器内插件弹框窗口 1234567891011121314-- 定义窗口信息local widgetInfo = DockWidgetPluginGuiInfo.new(\tEnum.InitialDockState.Float, -- 初始窗口是浮动的\ttrue, -- 可关闭\ttrue, -- 可初始化\t800, -- 默认宽度\t300, -- 默认高度\t200, -- 最小宽度\t150 -- 最小高度)-- 创建 DockWidgetPluginGuilocal dockWidget = plugin:CreateDockWidgetPluginGui(&quot;PluginTitle&quot;, widgetInfo)dockWidget.Title = &quot;插件样例&quot;dockWidget.Enabled = false 游戏窗口内UI 需要另外制作一个 ScreenGui 放置到插件脚本下面 插件需要发布到 Roblox 当需要 UI 显示时，将这个ScreenGUI 放置到 CoreGui下，不需要 UI 显示的时候，将 ScreenGui 放回插件脚本下面 1234567891011openUIBtn.Click:Connect(function()\tif Gui.Parent == script then Gui.Parent = game:WaitForChild(&quot;CoreGui&quot;)\telseif Gui.Parent == game:WaitForChild(&quot;CoreGui&quot;) then Gui.Parent = script\tendend)closeUIBtn.Activated:Connect(function()\tGui.Parent = scriptend) 一些插件可视化功能 选中物体高光 123456789101112131415161718192021222324252627282930function Select.SelectHightLight()\tlocal mouse = plugin:GetMouse()\tSelect.highlight = Instance.new(&quot;Highlight&quot;)\tSelect.highlight.FillColor = Color3.fromRGB(137, 255, 2)\tSelect.highlight.FillTransparency = 0.7\tSelect.highlight.Parent = script local function UpdateHighlight() local target = mouse.Target if target and target:IsA(&quot;Model&quot;) then if Select.currentAdornee ~= target then Select.highlight.Adornee = target end else if Select.currentAdornee ~= nil then Select.highlight.Adornee = nil end end\tend\tSelect.highlightConn = RunService.RenderStepped:Connect(UpdateHighlight)endfunction Select.Exit()\tSelect.highlight.Adornee = nil\tif Select.highlightConn then Select.highlightConn:Disconnect() Select.highlightConn = nil\tendend 一些踩坑 插件 plugin 全局引用不会传递给插件中的 ModuleScript，除非显式地传递它 12345678910--ModuleScriptlocal pluginfunction ModuleScript.Init(refPlugin)\tplugin = refPluginend--Scriptlocal ModuleScript = require(script.ModuleScript)ModuleScript.Init(plugin)","tags":["Roblox"],"categories":["Roblox"]},{"title":"UEFN 引擎操作和内置道具","path":"/2024/05/05/240512 UEFN-引擎操作和内置工具/","content":"来说说实际操作的一点东西 一、引擎相关编辑器设置：导航栏Edit/Editor Preferences 二、世界操作对对象操作在关卡视口里右侧有四个连着的并排的按键，都是对对象进行的操作按键 对对象操作的快捷键 Q 只选中对象 W 移动 E 旋转 R 缩放 如下面的粉色小熊，它身上有个红蓝绿坐标轴， 当坐标头部为圆锥形时，为移动操作，当坐标头部为正方体时，为缩放操作。 选中红蓝绿其一可对此对象进行该坐标轴单方向的移动或缩放操作 选中中间的白色按键，移动时可对象至鼠标位置，缩放时整个对象等比例缩放。 克隆当我们需要克隆一个或多个已有对象时，选中对象，同时按住 Alt 和对象身上的坐标任意方向拖动即可。 注意按一次 Alt 仅能克隆一次，同样的对象需要再次克隆的话需要松开 Alt 键再次按下。 三、Outliner 大纲栏操作四、Details 属性栏操作Transform ① 还原默认箭头：点击可将所有修改撤销，回到默认值。优点是可以知道自己改了哪些参数。 ② 等比锁定缩放：锁定时，在后面修改一个参数，其它参数都会同步修改。此锁定仅对后面三个参数生效，即在世界对对象直接操作缩放时，即使锁定，仍然按照所选中的三维方向或者等比进行缩放。 五、Devices 内置工具道具 工具位置：Content Browser/Fortnite/Devices 头文件：using &#123; /Fortnite.com/Devices &#125; 工具类型名称：一般是工具的名字，空格换成 _ ，最后加上 _device 定义完工具之后，按住 Ctrl 点击这个工具类名可以查看这个工具类的所有内置成员函数 barrier 障碍箱creative_object类成员函数： 12345678# 获取位置信息GetTransform()# 瞬间移动函数TeleportTo(Position:vector3, Rotation:rotation)TeleportTo(Transform:transform)# 过渡移动函数MoveTo(Position:vector3, Rotation:rotation, OverTime:float)MoveTo(Transform:transform, OverTime:float) /Logic：流程逻辑管理类Prop Manipulator操控这个工具影响覆盖区域内的一个或多个对象的属性 声明定义： 1@editable var PropManipulator : prop_manipulator_device = prop_manipulator_device&#123;&#125; 事件监听函数： 123456# 该区域的对象受到损害时发出信号。发送损害道具的agent。DamagedEvent.Subscribe()# 该区域的对象被销毁时发出信号。发送销毁道具的agent。DestroyedEvent.Subscribe()# 该区域的道具资源节点被收割时发出信号。发送从道具收割资源的agent。HarvestingEvent.Subscribe() 操作函数： 12345678910# 启用Enable()# 禁用Disable()# 耗尽区域内所有道具的资源ExhaustResources()# 补充区域内所有道具的资源RestockResources()# 恢复区域内所有道具的健康RestoreHealth() Timer Device 定时器六、UI相关BillBoard12345# 定义BillBoard@editable var BillBoard : billboard_device = billboard_device&#123;&#125;# 内置函数BillBoard.SetText(文本)","tags":["UEFN"],"categories":["UEFN"]},{"title":"UEFN Verse_01","path":"/2024/05/05/240505 UEFN-Verse1/","content":"UEFN Verse 程序篇1 虽然 UEFN 官网文档说用的是 C++ 编程，不过我觉得有时候好像更像 Python，有时候更像C#。也可以说是糅杂了很多不同编程语言的习惯，比如同一种命令可以有不同的编程语言的写法，这点还是蛮包容的。 一、写在前面部分快捷键 向 上/下 移动本行代码：Alt + ↑/↓ 同行往下多光标：Ctrl + Alt + ↓ 向下复制本行代码：Shift + Alt + ↓ 跟Roblox Studio的引擎区别编写代码时，如果需要选取提示的第一个，按Tab，我总是习惯按 Enter然后就换行了😣 语法规范 命名要用驼峰命名法 跟 Python 一样需要注意缩进 二、基本语法2.1、声明头文件123456# 默认模板头文件using &#123; /Fortnite.com/Devices &#125;using &#123; /Verse.org/Simulation &#125;using &#123; /UnrealEngine.com/Temporary/Diagnostics &#125;# 常用头文件using &#123; /Verse.org/Random &#125; 2.2、数据类型、常量变量 常量12# 常量值不可更改常量名:常量类型 = 值 变量 定义变量123# 定义一般变量的话一般需要初始化var 变量名: 变量类型 = 值var PlayerName: string = &quot;BlindArbiter&quot; 改变变量123# 总之改变变量值的话前面得加setset 变量名 = 新值set 变量名 += 增量 输出变量123# 输出变量时Print(PlayerName)Print(&quot;Hello, &#123;PlayerName&#125;&quot;) 基本数据类型 数据类型 logic 布尔型，ture or false int 整型，即整数 float 浮点型，即小数 string 字符串 enum 枚举 容器数据类型 Array：数组 用 [] 表示 一个数组的所有元素只能是同一类型 12345678910111213141516# 定义一维数组var array1 : []int = array&#123;1,2,3,6,8&#125;# 获取一维数组长度array1.Length# 定义多维数组var temp : int = 0array2 : [][]int = for (Row := 0..4): for(Column := 0..5): set temp += 1# 遍历多维数组if (columnLen : int = array2[0].Length):\tfor(Row:=0..array2.Length-1, Column:=0..columnLen): if (Element := array2[Row][Column]): Print(&quot;[&#123;Row&#125;][&#123;Column&#125;]:&#123;Element&#125;&quot;) Tuple：元组 用 () 表示 一个元组内的元素可以包含多种数据类型 123456# 定义，初始化值的时候可以把类型写上tuple1 : tuple(int,int,int) = (1,2,3)tuple2 : tuple(int, string, tuple(int, float)) = (1,&quot;BlindArbiter&quot;,(2,4.0))# 当然也可以不写，编译器会自行推断类型tuple1 := (1,2,3)tuple2 := (1,&quot;BlindArbiter&quot;,(2,4.0)) Map：映射，其实可以看作是数据类型被固定死的 Python 字典 和 Roblox 表 1234567# 定义var dict1 : [string]int = map&#123;&quot;id&quot; =&gt; 1001, &quot;coin&quot; =&gt; 100&#125;# 增加或修改键值对，通过set修改键值对的值，如果该键值对不存在为增加，存在为修改if(set dict1[&quot;coin&quot;] = 500):\tPrint(&quot;修改键值对&quot;)if(set dict1[&quot;health&quot;] = 100):\tPrinr(&quot;新增键值对&quot;) option：可以包含一个值，或者为空（不常用） 内置数据类型 message：消息类是一串可本地化的字符串，需要加上 &lt;localizes&gt; 用来本地化玩家所选语言。 12# 定义 messageMessageText&lt;localizes&gt;(str:string) : message = &quot;Hello,World!&quot; 2.3、类 定义类12# 声明 creative_device 是为了使这个脚本能被拖到世界里类名 := class(creative_device): 2.4、条件语句在 UEFN 里，可以跟 Python 一样写法 123456if (条件1):\t结果1else if (条件2):\t结果2else:\t结果3 如果后面的执行代码只有一行的话可以像C的写法 1if (条件) &#123; 结果 &#125; 还有另一种写法，在多条件时，会比较直观 123456789if:\t条件1 条件2 条件3 ...then:\t结果1else:\t结果2 2.5、循环语句 持续迭代循环123loop:\tif (条件): break 计数迭代循环12345678for (变量名 : 类型 = 迭代第一个数字..迭代最后数字):\t...# 前面没有声明过变量xfor (x : int = 1..5):\t...# 前面声明过变量xfor (x := 1..5):\t... 2.6、函数 函数返回类型 void 无返回值 logic 返回布尔型，true or false int 整型 float 浮点型 string 字符串 函数定义 12345678910# 基本格式:函数名(参数:参数类型)&lt;说明符&gt; : 函数返回值类型 = &#123;&#125;# 除此之外还有几种写法Func1() : void = &#123;&#125;Func2() : void = ...Func3(param1:int, param2:int) : int = param1 + param2 Func4(param1:int, param2:float) : float =\tblock: # 阻塞作用，等效于 Python 定义函数时的 pass 函数调用 12常量 : 变量类型 = 函数方法名()常量 := 函数名() 2.7、等待、异步和时间相关 等待 12# Sleep(秒) == Roblox-&gt; task.wait(秒)Sleep(2) 异步 123spawn&#123; 函数() &#125;spawn:\t... 获取时间戳 1GetSimulationElapsedTime() 三、对象123# @editable 表示在 UEFN 中公开变量，即需要在脚本属性处给此变量赋值# creative_prop UEFN里的一个内置类@editable var Prop: creative_prop = creative_prop&#123;&#125; UObjects不能用 new 和 delete 运算符。 所有的 UObjects 都由虚幻引擎管理内存和垃圾回收。如果通过 new 或者 delete 手动管理内存，可能会导致内存出错。 四、说明符 Specifier4.1、访问说明符一般在定义模块和类的时候声明 访问说明符 &lt;public&gt; 公开，访问不受限 &lt;internal&gt;（默认） 内部，仅限当前模块 &lt;protected&gt; 保护，仅限当前类和子类 &lt;private&gt; 私密，仅限当前类 4.2、效果说明符一般写在函数后面，指示函数行为 常用说明符 作用 &lt;override&gt; 覆盖/重写 原有类或函数， &lt;suspend&gt; 标记函数存在等待或支持暂停操作 五、内置类agent在很多封装的函数参数里看到，但是没有具体的文档说明这个，UEFN 对它的定义只有短短的一条： 1agent&lt;native&gt;&lt;public&gt; := class&lt;unique&gt;&lt;epic_internal&gt;: 研究了很多事件和函数，我目前的理解是，agent是一个代理，它代表了玩家的状态或者说触发事件的行为。 六、常用模块官方内置模块API：Verse API Reference 6.1、Random 模块头文件：using &#123; /Verse.org/Random &#125; 1234567using&#123; /Verse.osg/Random &#125;# 返回整型随机数GetRandomInt(最小值:int, 最大值:int):int# 返回浮点随机数GetRandomFloat(最小值:float, 最大值:float):float# 打乱数组内元素原先顺序，即重新洗牌Shuffle(Input:[]t where t:type):[]t = external &#123;&#125; 6.2、SpecialMath 模块头文件：/UnrealEngine.com/Temporary/SpatialMath 结构体和类 rotation vector2：二维向量 vector3：三维向量 123using&#123; /UnrealEngine.com/Temporary/SpatialMath &#125;var Vec : vector3 = vector3&#123;&#125;VecPos : vector3 = vector3&#123;X:=Vec.X, Y:=Vec.Y, Z:=Vec.Z &#125;","tags":["UEFN"],"categories":["UEFN"]},{"title":"UEFN从安装到运行","path":"/2024/04/24/240424 UEFN从安装到运行/","content":"学了一个星期UEFN，一些小小经验🧐 一些官方链接和学习文档 堡垒之夜官网：Fortnite – A Free-to-Play Battle Royale Game and More 虚幻文档：虚幻引擎5.3文档 | Epic Developer Community (epicgames.com) UEFN 创作者中心：Fortnite Creator Portal 一、安装UEFN用加速器打开Epic商城，搜索 Unreal Editor Fortnite 特别版 安装就好了，会同时给安装 Fortnite 的，我没记错的话当时是需要我105G左右的内存，好大😴。 二、UEFN引擎1.1、按键 按键 作用 Esc键 打开菜单 Tab 打开背包 Q 板编辑模式，也就是搭板编辑板，滚动鼠标中键切换板的样式，右键切换板的材料 Z,X,C,V 切换板的样式，分别是竖板，横板，斜板，屋顶的快捷键，非创造模式下点这几个键可直接进入该板的编辑模式 M 游戏模式下打开地图、任务、排行榜或其余玩家、输出等一些面板，在创造模式下打开时，任务栏会变成Fortnite自带的工具栏 两下空格 在编辑模式下，人物浮空 、 进入快速编辑模式，其中常用的，左键单击复制、右键单击剪切、X删除部件 1.2、实时同步 Fortnite 分为游戏模式和创造模式，当我们的 UEFN 和 Fortnite 建立连接之后，在 Fortnite 创作模式下做的任何修改会实时同步到 UEFN，UEFN 里修改的也会实时同步到 Fortnite 里。在游戏模式下做的任何改动则不会。 点击 Launch Session 就可以建立 Fortnite 和 UEFN 的连接，其中 Live Edit 如果没勾上，即在 Fortnite 的创造模式下做的任何更改不会同步到 UEFN。Auto Start Game的意思是默认进去就是游戏模式，不勾的话进去就是创造模式。 具体当前是什么模式的话，看 Fortnite 左上角。 模式切换：按 Esc 打开菜单，创造模式下点击 Start Game 就进入游戏模式，游戏模式下点击 End Game 就切换成创造模式。 注意如果在 Fortnite 里搭建的时一定要分清现在是创作模式还是游戏模式。 1.3、内容浏览器这一部分跟 Unity 的 Project 资产文件夹相同 Fortnite.Charaters：角色、动物资产 Fortnite.Consumables：官方内置消耗品资产 Fortnite.Devices：可交互、绑定事件函数的设备资产 Fortnite.Prefabs：完整的建筑模型资产，基本上是由Fortnite.Props里的资产搭成的直接可用的完整模型 Fortnite.Props：搭成Fortnite.Prefabs里的模型的零件，如单独的地板、墙面、家具等 Fortnite.Weapon：武器资产 1.4、多视角编辑默认都是 Perspective 视角下进行开发，不过为了更好地调整一些资产的位置，可以使用2D视图来编辑。 以 Top 视角为例，当我们选中某个资产时，可以直接移动它在整个俯视图当中的位置到我们想要的位置。 在这个模式下要按住右键才能拖动画面。 1.5、Place Actor在 UEFN，项目的游戏世界被称作关卡，也被称为Level Actor 大概就是静态资产、音效、摄像机、角色玩家之类可以放置到我们的游戏世界的任意对象，可以把 Place Actor 理解成把这些东西放置到世界的一个工具栏（？） 二、程序—Verse2.1、环境使用的是 Verse，如果电脑本身装有 VSCode环境，点击 Verse 就会直接打开 VSCode 跳转到项目的代码库，在编写代码即可。 2.2、创建Verse文件 对 Verse Explorer 里的项目文件夹右键单击可以新建一个 Verse文件，这个文件就是用于编写代码的文件。 新建 Verse文件，左边是选择 Verse文件的模板，右边主要改脚本名字，就可以创建脚本文件了，可以选择创建模板脚本还是空脚本。 创建完的文件可以在两个路径下找到：①Verse Explorer 下的 Content 里，②Content Browser 下的 Content 2.3、编译脚本 可以在 VSCode 里编译，如果是这个下标是红色的话，那么代表代码有bug，会有报错显示。 也可以在导航栏的 Verse 里 Build Verse Code编译程序代码 2.4、将脚本应用到世界将脚本拖到世界之前，一定记得编译脚本 注意如果编写脚本时有定义场景里的对象，那么一定要在属性栏里把相应的对象绑上去，否则脚本会不起作用 三、平台相关3.1、年龄认证1、据说最快的方式是信用卡验证，不过总报错，而且我也没有相应的银行卡账户，只能是人脸验证或者身份证验证。 2、人脸认证！为什么验了几次都不过呀！我是长得多显小吗！生气了，让检测平台猜😠 3、最慢的就是证件认证了，加载就要老半天，从上午加载到下午都加载不出来😴 所以我到现在也没能成功年龄验证，好吧，下次再试试 3.2、公开游戏加入创作者计划Support-A-Creator才能发布公开游戏，不过目前中国大陆被禁止，中国香港才行 3.3、私有版本游戏在引擎Project里点击 Upload to Private Version 可以上传私有游戏版本，同时得到一个 Island Code，复制这个 Island Code 到 Fortnite 里可以测试你的游戏。 还可以在 Create 网页里点开 Project，再点开你的项目，在 Private Versions 里会有此项目所有私有版本的记录和 Island Code。 3.4、群组协作 在Create里左上角可以选择是个人还是群组 创建新群组的话，也是在这个按钮里创建 创建新群组的前提是通过年龄认证，满18岁","tags":["UEFN"],"categories":["UEFN"]},{"title":"Cisco相关1","path":"/2024/04/14/240414 Cisco相关1/","content":"cisco又是你cisco又是你cisco又是你 CCNA相关 Cisco基本命令配置相关 Router# EXEC模式（特权级别1），表示可执行普通命令Router(config)# 处于设备的全局配置模式（也称为特权级别 15），表示可执行配置命令。 进入全局配置：conf t 进入单个端口：int [端口]进入多个端口：int range [端口范围] 创建子端口：int [端口].[子端口号] 将子端口与 VLAN 连接：encap dot1Q [vlan_id] / encapsulation dot1Q [vlan_id] 禁用端口：shutdown启用端口：no shutdown / no sh Show相关 查看设备的端口和IP配置：show running-config 查看路由IP配置：show ip route 查看VLAN配置：show vlan brief 查看隧道配置：show interface tunnel [tunnel_id] 路由相关 打开加密特权 EXEC 模式：enable secret [密码] 设置MOTD警告信息：banner motd [显示文本] 配置IP：ip address [IP地址] [子网掩码] 本地链路：ip addr [本地链路地址] link-local动态配置IP：ip addr dhcp 配置默认网关：ip default-gateway [默认网关] 配置静态路由：ip route [目的地址网段] [子网掩码] [目的路由器以太网ip(最近的IP地址)]配置默认路由：ip route [0.0.0.0] [0.0.0.0] [目的路由器以太网ip] 单臂路由：实现不同VLAN间通信的技术 常见于创建子接口分配 VLAN 号 创建子接口：int [端口].[子端口号] 将子接口与 VLAN 连接：encap dot1Q [vlan_id] （encapsulation ) 进入RIP 协议配置模式：router rip 版本：version 2 禁用网络汇总：no auto-summary 更改接口封装类型为PPP（点对点协议）：encapsulation ppp 在设备上配置本地用户： username [本地用户名] password [密码]在设备上删除本地用户：no username [本地用户名] password [密码]查看路由设备上配置的本地用户： show running-config | include username 配置PPP链路上的身份验证方式为CHAP（质询握手身份验证协议）：ppp authentication chap(在两台路由器上启用使用CHAP身份验证) ip nat inside: 此配置标识接口为内部网络接口ip nat outside: 相对应地，此配置标识接口为外部网络接口 交换机相关 创建 VLAN：VLAN [vlan_id] 给 VLAN 命名：name [vlan名称] 删除 VLAN：no VlAN [vlan_id] 配置端口类型：switchport mode [类型] 接入端口（传输单个 VLAN 数据）：switchport mode access 中继端口（传输多个 VLAN 数据）：switchport mode trunk 分配 VLAN 给接入端口：switchport access VLAN [vlan_id]分配 原生VLAN 给中继端口：switchport trunk native [vlan_id] 验证 VLAN 配置：show vlan brief 配置VTP用于交换机间自动传播VLAN配置信息 设置域名：vtp domain [域名] 模式：vtp mode [server/Client/Transparent] 口令：vtp password cisco 版本：vtp version 2 VPN相关 DCHP动态主机配置协议相关 DHCP服务器 创建DHCP地址池：ip dhcp pool [dchp地址池名称] 地址池IP地址范围：net [网络地址] [子网掩码] 默认网关：default-router [默认网关] DNS服务器：dns-server [dns服务器] 排除地址池的特定ip地址：ip dhcp exclude [特定ip] DHCP中继：解决DHCP服务跨子网分配 IP 问题 ip helper-address [DHCP服务器IP地址] 配置SSH12345678Router(config)# hostname R4创建用户和密码R4(config)# username admin secret ciscoR4(config)# line con 0R4(config-line)# line aux 0R4(config-line)# line vty 0 4R4(config-line)# login localR4(config-line)# transport input ssh 创建OSPF开放式最短路径优先 配置OSPF进程号：router ospf [osfp_id] 路由器ID：router-id [路由器id] 指定OSPF区域和网络：network [网络地址] [通配符掩码] area [area_id] 禁止接口路由更新：passive-interface [需设置被动的接口] VTY线路网络设备虚拟终端接口 1234line vty 0 [number]loginpassword [password] // 或使用更安全的密码加密方法，如enable secrettransport input [all | none | ssh | telnet] 创建隧道 配置隧道进程号：int tunnel [tunnel_id] 隧道接口：tunnel source [使用的端口] 目的地址：tunnel destination [目的ip地址] 配置ip：ip addr [ip] [子网掩码] 使隧道通过 GRE 传递 IP 流量：tunnel mode gre ip 查看配置：show interface tunnel [tunnel_id] ACL相关设置ACL 1234567891011-- 创建编号 标准 ACLaccess-list [ACL_number] [deny|permit] [IP地址] [通配符掩码]-- 创建命名 标准/扩展 ACL：ip access-list [standard/extended] [ACL编码/名称]-- 注意ACL过滤流量规则有先后顺序-- 允许其他所有网段流量access-list [1] permit any-- 允许单一主机ip地址access-list [99] permit host [10.0.0.1] 应用ACL到对应的接口：ip access-group [ACL_number/ACL名称] in 取消应用：ip access-group [ACL_number/ACL名称] out 计算子网掩码对应的通配符掩码 123456789方法一：1转0，0转1子网掩码/27： 11111111.11111111.11111111.11100000 = 255.255.255.224对应通配符掩码：00000000.00000000.00000000.00011111 = 0.0.0.31方法二：从 255.255.255.255 中减去子网掩码 255.255.255.255- 255.255.255.240-----------------= 0. 0. 0. 15 PC机相关 ping tracert 查找拓扑可能存在错误的一些思路 端口是否打开 ip地址配置 实验链接5-1 Packet Tracer –配置RIPv2 5-2 Packet Tracer - 配置 IPv4 的 EIGRP 基本设置 5-3 Packet Tracer –配置多区域OSPFv2 6-1 Packet Tracer - 配置 PAP 和 CHAP 身份验证 6-2 Packet Tracer - 排除 PPP 身份验证配置故障 7-1 Packet Tracer - 配置单臂路由器 VLAN 间路由 7-2 Packet Tracer – VLAN 间路由练习 7-3 Packet Tracer – 配置中继_交换机配置中继模式命令 8 Packet Tracer – 实施静态 NAT 和动态 NAT 9-1 Packet Tracer - 配置命名的标准 ACL 9-2 Packet Tracer - 配置编号标准 IPv4 ACL 10-1 Packet Tracer - 配置扩展 IPv4 ACL - 场景 1 test2 Packet Tracer –1 分层网络设计 test3 Packet Tracer – VLAN 间路由练习 test4 Packet Tracer – 实施静态 NAT 和动态 NAT","tags":["cisco","ccna"],"categories":["编程相关"]},{"title":"《少有人走的路》","path":"/2024/03/18/240318 《少有人走的路》/","content":"忙里偷闲 自律问题和痛苦 如果不顾一切地逃避问题和痛苦，不仅错失了解决问题推动、推动心灵成长的契机，而且会使我们患上心理疾病。长期的心理疾病会使人的心灵停止生长。不及时治疗，心灵就会萎缩和退化，心智就永远难以成熟。 “你不能解决问题，你就会成为问题。”如果不去直面问题，解决问题，问题就会永远存在。 自律究竟包括哪些技巧呢？如何通过自律，消除人生的痛苦呢？简单地说，所谓自律，是以积极而主动的态度，去解决人生痛苦的重要原则，主要包括四个方面：推迟满足感、承担责任、尊重事实、保持平衡。 看完感觉其中推迟满足感是最容易做到的，保持平衡最容易被忽略也是最难的。 解决问题的时机 37岁快要结束的那年春天，我星期天在户外散步，看见邻居正在修理除草机。我同他打过招呼，羡慕地说：“哦，你真是能干啊！我从来就不会修理这种玩意儿，还有其他别的东西。”他马上回答：“那是你没有花时间去尝试罢了。”我继续散步，内心越来越不平静，他这句简单而意味深长的话，给了我很大的震撼。我扪心自问：“他说的可能是对的。伙计，也许你真的没那么差劲儿，是吗？” Taketime and just do it. 永远不要对没有做过的事情说不。 逃避自由 力图把责任推给别人或是组织，就意味着我们甘愿处于附属地位，把自由和权力拱手交给命运、社会、政府、独裁者或者上司。 为了躲开责任带来的痛苦。数不清的人甘愿放弃权利，实则是在逃避自由。 作为成年人，整个一生都充满选择和决定的机会。他们接受这一事实，就会变成自由的人；无法接受这种事实，永远都会感到自己是个牺牲品。 要做怎样的事、要成为怎样的人、要过怎样的人生应该是自己选择的自己决定的。对于每个我深思熟虑之后做出的选择，都是我的选择，它可以是别人眼里最糟糕的决定，但是却是我生活里每道鲜艳的色彩，我的生活就应该是鲜活的热烈的我所向往的，而不是别人口中该有的样子。 忠于事实 忠于事实是自律的第三条原则。我们需要实事求是，杜绝虚假，因为虚假与事实完全对立。我们越是了解事实，处理问题就越是得心应手；对现实了解得越少，思维就越是混乱。虚假、错觉和幻觉，只能让我们不知所措。我们对现实的观念就像是一张地图，凭借这张地图，我们同人生的地形、地貌不断协调和谈判。地图准确无误，我们就能确定自己的位置，知道要到什么地方，怎样到达那里；地图漏洞百出，我们就会迷失方向。 尊重事实远远比我们想象地困难太多，就拿看清自己，自知之明来说，我们似乎总能把自己想到太美好或者太糟糕，或许是不中肯地评价自己，当你说你热爱你喜欢某个人或事物的时候，但事实真的如此吗。人很难看见自己，我们的大脑或者说意识，很会欺骗我们自己，除非借外物外力以及不断地自省。 迎接挑战 因为畏惧挑战带来的正常的痛苦，因而不断逃避和撒谎，无异是有意回避有益的痛苦，这就可能产生相应的心理疾病。 长时间自欺欺人，使人的愧疚积聚，就会导致心理疾病。 所以说为什么坦坦荡荡光明磊落的人能活得更自由快乐。 保持平衡 保持平衡，意味着确立富有弹性的约束机制。不妨以生气为例。当我们心理或生理上受到侵犯，某个人、某件事令我们伤心和失望时，我们就会生气。要正常地生活，生气是一种必不可少的反击方式。从来不会生气的人，注定终生遭受欺凌和压制，直至被摧毁和消灭。必要时候的生气，可以使我们更好地生存。另一方面，我们受到侵犯，不见得是侵犯者对我们怀有敌意。有时候，即便他们果真有意而为，我们也要适当约束情绪，因为正面冲突只会使处境更加不利。大脑的高级中枢——判断力，必须约束低级中枢——情绪。在这个复杂多变的世界里，要想人生顺遂，我们不但要有生气的能力，还要具备克制脾气的能力。我们要善于以不同的方式，恰当地表达生气的情绪：有时需要委婉，有时需要直接；有时需要心平气和，有时不妨火冒三丈。表达生气，还需要注意时机和场合。我们必须建立一整套灵活的情绪系统，提高自己的“情商”。相当多的人直到青年乃至中年时期，才能掌握如何生气的本领，而有些人一辈子都没有学会如何生气。 不愿放弃人生的某些东西，一定会给心灵带来痛苦。九岁的我贪恋风驰电掣，不肯放弃一时的快感，来换取转弯时的平衡，最终让我体会到：失去平衡远比放弃更为痛苦。我想不管是谁，经过人生旅途的急转弯，都必须放弃某些快乐，放弃属于自己的一部分。除非永远停在原地，中止生命之旅，否则这样的放弃是不可避免的。 保持平衡的最高原则是“放弃”，失去平衡远比放弃更痛苦。 放弃与新生 兼容并包的前提，在于你获得的永远比放弃的多。自律，就是一种自我完善的过程，其中必然经历放弃的痛苦，其剧烈的程度，甚至如同面对死亡。但是，如同死亡的本质一样，旧的事物消失，新的事物才会诞生。死亡的痛苦是诞生的痛苦，而诞生的痛苦也是死亡的痛苦。生与死，好比是一枚硬币的两面。要建立更新的观念与理论，旧有的观念和理论就必须死去。 你能做什么，取决于你能不做什么。放弃才是得到。 爱爱的定义 爱是一种意愿。我之所以用“意愿”来定义爱，是为了让它与一般的“欲望”有所区别。并不是所有的欲望都能够转化成行动，而只有强大到足以转化成行动的欲望，才能够称之意愿。人人都有爱他人的欲望，但很多人仅仅只把这种爱停留在想法和口头上。想爱不等于去爱，爱的想法不等于爱的行动。真正的爱是行动，是一种由意愿而产生的行动。爱一个人却没有付诸行动，就等于从未爱过。 冲突的风险 真正有爱的人，绝不会随意指责爱的对象，或与对方发生冲突。动辄与所爱之人发生冲突，多半是以为自己在见识或道德上高人一等。真心爱一个人，就会承认对方是与自己不同的、完全独立的个体。基于这样的认识，我们不会轻易地对心爱的人说：“我是对的，你是错的；我比你更清楚怎么做更合理，知道什么对你更有好处。”因此，富有爱心的人，经常处于两难境地——既要尊重对方的独立性，又渴望给予对方爱的指导。勤于自省，才能走出这种境地。首先必须进行自我反省，确认自己的观点是否有价值。 “我看清问题的本质吗？”“我的动机是为对方着想吗？”“我发现了问题的症结，还是处于模模糊糊的假想？”“我是否真正了解所爱的人？”“他的选择可能是正确的，我是否因经验有限才觉得他的选择不够明智呢？”“我想给所爱的人提供指导，是否出于一己之私？” 真正以爱为出发点的人，应该经常反思上述问题。 这几个问题感觉在所有的人际交往上都适用。 我知道人间处处有爱，请你放心地成为你自己；我相信人生可以变得更加完美，就让我们加入这场人生的游戏。 译者对John Denver 的《Love is Everywhere》歌词的翻译比音乐软件里的翻译更妙。 恩典潜意识的奇迹 如果你更多地了解自己，就会发现你的潜意识——这个你所知甚少的“自己”，有着极为丰富的内涵，它的神秘性超出你的想象。 潜意识是一片神秘的领域，梦是它存在的最好证据。 做梦者感觉自己出了问题，潜意识就安排了一出戏，告诉他问题的来源——做梦者原本难以意识到的来源。 为在复杂的社会上获得生存，找到自己的位置，我们人人都戴上了面具。因此，意识塑造的自我，与潜意识中的自我，有时相差甚远。不过，意识的能力终归有限，常常让真实的自己暴露出来。不管如何掩饰，潜意识都会看清真相。 在心理健康状况恶化之前，潜意识就会察觉到我们的变化，注意到我们的适应能力越来越差。它通过各种方式，提醒我们情况变得不妙——频繁的噩梦、过度的焦虑、极度的沮丧，这些症状在我们身上不断出现。虽然意识可能与现实脱节，但无所不知的潜意识总能看清真相，并以以上症状来提醒我们做出及时的改变。 进化的奇迹 归根结底，推动个人乃至整个物种克服懒惰和其他自然阻力的力量究竟是什么？其实我们已经给它取了名字，那就是”爱“。我们之所以能够成长，在于持续的努力；我们之所以能够付出努力，是因为懂得自尊自爱。对自己的爱是我们愿意接受自律，对别人的爱让我们帮助他们去自我完善。自我完善的爱，是一种典型的进化行为，具有声声不息的特征。在生物世界中，存在着永久而普遍的进化力量，体现在人类身上，就是具有人性的爱。它违反熵增的自然规律，是一种永远走向进步的神奇的力量。 熵与原罪 懒惰就像魔鬼一般狡诈，让人们不仅擅长伪装和欺骗，还会想法设法让懒惰变得合情合理。哪怕患者的意识已成熟到一定程度，也未必有能力去了解懒惰的本质，并与之进行对抗。即使他们有机会进入某个领域，获取某种新的知识，就很容易出现懒惰的情绪并产生恐惧。 我们心中都有一个病态的自己和一个健康的自己。即使内心充满恐惧，性情无比顽固，我们身体里仍有一部分神奇的力量——也许这力量并不强大，但它是积极的，它推动着我们心智的成熟。它喜欢改变和进步，向往新的、未知的领域。它愿意做好属于自己的工作。甘愿冒心智成熟带来的一切风险。于此同时，不管我们表面看上去有多么健康，心灵进化到了怎样的程度，我们的身体里也始终有另一部分力量——它可能同样不算强大，它不想让我们付出任何辛苦。它坚守熟悉的、陈旧的过去，害怕任何改变和努力。它只想不惜代价地享受舒适，逃避痛苦，宁愿为此付出“无效”、“停滞”乃至“退化”的代价。P263-264 我相信，大多数心理疾病的模式都是这样：早在症状频繁出现之前，疾病就存在于人的精神世界里。症状本身不是疾病，而是疾病的外在表现，同时也往往成为治疗的开端。尽管它们为我们所厌恶和恐惧，但是，它们是来自潜意识的一种至关重要的信息。它们使患者意识到自己的身心健康已经出了问题，促使他们及时自我反省，或接受必要的心理治疗。大多数人总是拒绝这种提醒，他们以各种方式逃避，不肯为疾病承担起责任。他们对自己的症状视而不见，还振振有词地说：“人人都可能出现异常状况，或者偶尔遭受到小灾小病的打击。”为了逃避应当承担的责任，他们可能会中断工作，停止驾车，搬到新的城市，或者放弃参加某些活动。他们也可能吃止痛药，服用医生开的药丸，借助酒精或其他药品麻醉自己，试图自行消除这些症状。即便承认自己确实出现了某些奇特的症状，他们也会下意识地把责任归咎于外界——家人的漠视、朋友的虚伪、上司的压榨、社会的病态，或是自身命运不济。只有少数人能正视自己的症状，他们清楚地意识到，这些症状说明他们内心深处真的出了问题。他们听从潜意识的暗示，并从中获得帮助。他们承认自己的缺点和不足，忍受治疗中必经的痛苦，也由此得到巨大的回报。","tags":["文学"],"categories":["读书笔记"]},{"title":"史铁生散文","path":"/2024/02/10/240210 史铁生散文/","content":"最近重读了史铁生老师的文字，每一次读都会被触动。 ⭕《我与地坛》 在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。 一个人，出生了，这就不再是一个可以辩论的问题，而只是上帝交给他的一个事实；上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。 剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。 我曾经想过人生的结局是什么，人生的结局是死亡，我们注定要死，那我们还要不要活着？或许是因为还年轻，很多问题从我脑海里蹦出来之后，我想不出结果，就把它抛到脑后，因为总觉得还离我很远。就好像现在，我又读到史铁生的文字，几个月或者前几年前没有答案石沉大海的问题，像一颗石头重新投入我的脑海，虽然可能还是会像之前一样抛不出水花，我也试图能留下一点痕迹。史铁生的文字，与其说是解脱，我更觉得他平静自然，他好像认为死就是一个自然而然的事情，就像花会枯萎、水会干涸，就像他说的是一件不必急于求成的事。与其说为了害怕死亡、畏惧死亡而杞人忧天，我更愿意认为我们活着是为了我们活着的每一个瞬间、每一天，我也更希望我活着是为了每一道我能看见的颜色和风景、为了每一段我能欣赏的声音和旋律、为了每一个能与我相知相识的朋友和灵魂，为了每一个我能快乐不知时日变迁的奇遇和冒险！为了活着而活着，或者说活着就是用自己喜欢的方式去等死吧。 ​ 谁又能把这世界想个明白呢？世上的很多事是不堪说的。你可以抱怨上帝何以要降诸多苦难给这人间，你也可以为消灭种种苦难而奋斗，并为此享有崇高与骄傲，但只要你再多想一步你就会坠入深深的迷茫了：假如世界上没有了苦难，世界还能够存在么？要是没有愚钝，机智还有什么光荣呢？要是没有丑陋，漂亮要怎么维系自己的幸运？要是没有了恶劣与卑下，善良和高尚又将如何定界定自己又如何成为美德呢？要是没有了残疾，健全会否因为其司空见惯而变得腻烦和乏味呢？我常梦想着在人间彻底消除残疾，但可以相信，那时将由患病者代替残疾人去承担同样的苦难。如果能够把疾病也全数消灭，那么这份苦难又将由（比如说）相貌丑陋的人去承担了。就算我们连丑陋，连愚昧和卑鄙和一切我们所不喜欢的事物和行为，也都可以通通消灭掉，所有的人都一样健康、漂亮、聪慧、高尚，结果会怎样呢？怕是人间的剧目就全要收场了，一个失去差别的世界将是一潭死水，是一块没有感觉没有肥力的沙滩。 ​ 看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。 ​ 于是就有一个最令人绝望的结论等在这里：有谁去充任那些苦难的角色？又有谁去体现这世间的幸福、骄傲和快乐？只好听凭偶然，是没有道理好讲的。 ​ 就命运而言，休论公道。 ​ 我常以为是丑女造就了美人。我常以为是愚氓举出了智者。我常以为是懦夫衬照了英雄。我常以为是众生度化了佛祖。 莫名想到三体里一句，“死亡本身是公平的，因为人人都会死，但死的原因、过程却不是。” 或许我们有时候必须承认苦难是世界的必然？毕竟在命运面前，我们一切话语，反抗都是沉默无声的。 很喜欢最后一句。 一个人质报复一场阴谋的最有效的办法是把自己杀死。 要是有些事我没说，地坛，你别以为是我忘了，我什么也没忘，但是有些事只适合收藏。 当然，那不是我。但是，那不是我吗？ 谁懂这个陈述和反问的含金量啊！ ⭕《我二十一岁那年》 真是人不当死鬼神奈何其不得。 上帝为了锤炼生命，将布设下一个残酷的谜语。 命运中有一种错误是只能犯一次的，并没有改正的机会，命运中有一种并非是错误的错误，但这却是不被原谅的。 但是有一天我认识了神，他有一个更为具体的名字——精神。在科学的迷茫之处，在命运的混沌之点，人惟有乞灵于自己的精神。不管我们信仰什么，都是我们自己的精神的描述和引导。 ⭕《“忘了”与“别忘了”》 如果用不幸的残疾去换取某种特权，如果像个永远长不大的孩子那样总需依仗父母的娇惯，那么，当人们送来了特权也送来了嘲讽，送来了迁就也送来了轻蔑，我们就没理由反对这种搭配了，因为是我们自己先把自己摆在了低于常人的位置上，摆在了深渊里。 所以我一直认为人的主观能动性是很重要的，你认为的自己是什么样的，你把自己摆在什么位置上，很大程度能决定你能做成什么样的事情。或许这个时候你会发现你其实拥有去做到想做到的勇气和自由。 ⭕《我的梦想》 上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。如果不能在超越自我局限的无尽路途上去理解幸福，那么史铁生的不能跑与刘易斯的不能跑得更快就完全等同，都是沮丧与痛苦的根源。 欲望无尽，欲壑难平，壁垒之外还是壁垒吧，所以说知足常乐。 ⭕《病隙碎笔》 我不高兴，是指精神的我；我发烧了，是指肉体的我；我想自杀，是指精神的我要杀死肉身的我。 太震撼了这一句！","tags":["文学"],"categories":["读书笔记"]},{"title":"VS/VSCode踩坑","path":"/2023/10/11/231011 VS VSCode踩坑/","content":"随机掉落更新😴 中文编码问题解决方法在使用VS运行程序的时候会报这样的错，”常量中有换行符”，运行之后是这样的乱码的。 从顶栏当中选择工具-自定义，再切去命名栏，把菜单栏那一项改成文件后，选择添加命令。 在添加命令的界面，类别选文件，命令选择高级保存选项，然后确定，把这个命令添加上去。 再从顶栏的文件当中找到我们刚刚添加好的高级保存选项。 把编码方式换成另一种中文的，例如我的本来是EUC的那个简体中文，就换成GB2312的简体中文，换完之后编码就没问题了。 “cout” 不明确 将using namespace std; 删除后Ctrl+S保存cpp文件，再加上using namespace std; 保存cpp文件就解决了。 VSCode 换色导航栏 File/Preferences/Theme/Color Theme 快捷键是 Ctrl+K, Ctrl+T","tags":["VS"],"categories":["踩坑"]},{"title":"Qt乱谈","path":"/2023/09/09/230909 Qt/","content":"一些我学到的我用到的且跟C++有区别的地方 先说Qt，一个完全面向对象的C++图形用户界面应用程序框架 试图驯化Qt简单地开发个小游戏，程序到今天算是收尾了🧐 1、QDubug一个调试输出功能的库 123#include &lt;QDebug&gt; --声明头文件//输出的一种最常用格式qDebug()&lt;&lt;&quot;score:&quot;&lt;&lt;score; 2、 对象树 QObject是以对象树的形式组织起来的 当我们创建一个QObject对象时，可以设置这个对象的父对象parent，这个被创建的对象会自动添加到其父对象的children()列表里（注意此父对象非继承意义上的父类） 当父对象析构的时候，其children()列表中的所有对象也会被析构 QWidget是能够在屏幕上显示的一切组件的父类 局部对象的析构顺序按照其创建顺序的相反过程 3、信号与槽12connect(sender, signal, receiver, slot)connect(信号发送者, 发送的具体信号, 信号接受者, 信号的处理(槽函数)) 优点：松散耦合，信号发送端和接收端本身无关联，通过connect连接耦合。 信号和槽函数返回值是 void 信号只需要声明，不需要实现，槽函数既要声明也需要实现 断开信号 disconnect() 3.1、自定义信号和槽 自定义信号：emit发送信号—— emit 对象指针-&gt;信号() 信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。 重载冲突：连接带参数的 信号与槽 需要利用函数指针 -&gt; 明确指向的函数地址 1234void(类1:: *函数指针1)(所带参数类型) = &amp;类1::信号1;void(类2:: *函数指针2)(所带参数类型) = &amp;类2::信号2;connect(sender, signal, receiver, slot);调用自定义信号函数Func(); 12345678910// 无参信号和槽连接void(Teacher:: *teacherSignal)(QString) = &amp;Teacher::signal1;void(Student:: *studentSlot)(QString) = &amp;Student::slot1;connect(ls,teacherSignal,xs,studentSlot);Func();// 按钮控制信号和槽 QPushButton * btn = new QPushButton(&quot;下课&quot;,this)connect(btn,&amp;QPushButton::clicked,this,&amp;Widge::Func)// 信号连接信号connect(btn,&amp;QPushButtomn,ls,teacherSignal) 3.2、lambda表达式用于定义和创建匿名的函数对象 12[函数对象参数](操作符重载函数参数)mutable-&gt;返回值&#123;函数体&#125;// 其中 mutable 看需求是否添加 函数对象参数 [] 标识一个lambda的开始，不能省略 [] 没有使用任何函数对象参数 [=] 可使用lambda所在范围内所有可见的局部变量，值传递 [&amp;] 可使用lambda所在范围内所有可见的局部变量，引用传递 [this] 函数体内可使用lambda所在类中的成员变量 [a] a按值传递，默认函数是const [&amp;a] a按引用传递 4、定时器 利用事件 123456789void timerEvent(QTimeEvent * ev);//启动定时器startTimer(1000) // 参数1 间隔 单位毫秒// 多个定时器id1 = startTimer(1000)if(ev-&gt;timerId()==id1)&#123; // 判断唯一标示 static int num = 1; ui-&gt;label-&gt;setText(QString::number(num++));&#125; 利用定时器类 QTimer 123456789101112// 创建定时器对象QTimer * timer()&#123; // 启动定时器 timer-&gt;start(1000); // 停止定时器\t// timer-&gt;stop(); // 发送timeout信号监听，lambda匿名函数实现 connect(timer, QTimer::timeout, [=]()&#123; static int num = 1; ui-&gt;label-&gt;setText(QString(num++)); &#125;)&#125; 5、QPainter 绘图事件12345678// 声明绘图事件void paintEvent(QPainEvent *);// 实例化画家对象 this指的绘图设备QPainter painter(this);// 画图片painter.drawPixmap(int x,int y,int w,int h,const QPixmap &amp;pm);painter.drawPixmap(QRect(int x,int y,int w,int h),const QPixmap &amp;pm);// 如果要手动调用绘图事件，可用update() 6、QVector 容器(动态数组)1vector&lt;数据类型*&gt; 容器名 12vector&lt;类1 *&gt; vector1; // 装类1的容器vector1vector&lt;类1 *&gt;::iterator it; // 名为it的迭代器，可遍历和操作容器 遍历和操作容器 1234for(it=vector1.begin();it!=vector1.end();)&#123; if((*it)-&gt;done())&#123; it=vector1.erase(it); &#125; erase()：从容器中删除指定位置的元素，并返回指向被删除元素之后位置的迭代器 7、QSound 音乐音效12345// 在导入QSound时，需要先在 .pro工程文件中加入QT += multimedia// #include&lt;QSound&gt; 1QSound::play(音乐); 数据类型转换 QString -&gt; char *： 12// 先转成 QByteArray [.toUtf8()] 再转成 char * [ .data()]qDebug() &lt;&lt; str1.toUtf8().data(); 子类—&gt;父类： 123// 强制类型转换符static_cast// 例如父类QEvent * e, 子类QMouseEvent * evQMouseEvent * ev = static_cast&lt;QMouseEvent *&gt;(e); 一些报错0x01 No rule to make target ‘……’, needed by ‘……’. Stop.这个报错可能是 .pro 文件里面有重复的头文件，删除掉重修构建就好了 0x02 The inferior stopped because it received a signal from the operating system. 这个报错通常是由于访问无效的内存地址引起的，会使得程序异常结束，后来回去看代码找到这个我释放了空间但是又试图访问的地方改掉就好了","tags":["Qt"],"categories":["编程相关"]},{"title":"MySQL踩坑笔记","path":"/2023/07/09/230709 MySQL踩坑/","content":"不定期更新😴 上次在Unity里接数据库用的是SQLite，这次试着用用MySQL MySQL Connector NET 卸载问题因为打算在VS里引用MySQL.Data.dll，于是下载了connector8.0.25，但是VS报错说不支持， 打算卸掉换一个版本，尝试过控制面板删除、火绒粉碎、注册表删除，但是都卸不掉😕 微软的支持里有个Fix problems that block programs from being installed or removed - Microsoft Support，点击下载卸载疑难解答程序； 如果下载的时候浏览器显示这类文件可能会损害你的设备的话，可以换一个浏览器下载，之后打开选择卸载掉Connect NET就好了，其他应用有相同情况也可以用这个","tags":["MySQL"],"categories":["数据库"]},{"title":"Git踩坑笔记","path":"/2023/06/28/230628 Git踩坑/","content":"不定期随机掉落更新😴 2023 年 7 月 3 日最近在用Git管理项目，又多踩了些坑2023 年 6 月 20 日尝试用Git项目协作，版本控制，就记一些踩坑 一些指令 添加文件到暂存区：全部git add . / 指定git add 文件名.后缀 提交修改：git commit -m &quot;备注(可省)&quot; 推送代码到仓库：git pull 推送代码到远程仓库：git pull origin 想要推送的分支名 获取更新：git push 本地新建分支：git branch 新分支名字 本地删除分支：git branch -d 分支名字 查看本地分支：git branch 查看远程分支：git branch -r 查看所有分支：git branch -a 查看本地分支与远程分支的映射关系：git branch -vv 列出所有与当前Git仓库关联的远程仓库及URL：git remote -v 0x01 OpenSSL SSL_read: Connection was reset, errno 10054 报错原因是我们的DNS被污染了，国内ping到的github.com可能是被篡改了，我们重新配置正确的ip就好了 查询下面三个github相关域名ip：域名查询网址IPAddress.com 123github.comgithub.global.ssl.fastly.netcodeload.Github.com 打开C:\\Windows\\System32\\drivers\\etc\\hosts，如果有的话检查域名是否正确，如果没有的话在末尾加上刚刚查的ip地址和域名，格式像这样： 需要注意的是我们每次连不上可能就要改一遍ip地址，旧的地址要不就删掉要不就注释掉 cmd刷新DNS：ipconfig /flushdns 0x02 There is no tracking information for the current branch. Please specify which branch you want to merge with. 在协作项目使用git pull出现的问题，因为本地的分支和远程的分支没有建立关联导致的 1git branch --set-upstream-to=origin/远程分支名 本地分支名 再通过 git branch -vv 查看是否追踪成功 撤销本地分支和远程分支的关系： 1git branch --unset-upstream 0x03 refusing to merge unrelated histories这个我是在使用git pull出现的问题，我认为应该是两个分支不同导致的，在后面加上--allow-unrelated-histories 允许合并就能更新下来 1git pull --allow-unrelated-histories 不过使用这条指令后会进入一个如下图所示的界面： 可以直接关闭退出，反正已经更新好了，也可以在键盘上按INS键切换模式，可以在窗口最下面那行看到，切换到“insert”模式后按ESC键，输入 :wq 回车就会退出回到原来的界面。 0x04 error: ‘…/‘ does not have a commit checked out报错原因是文件下面有隐藏文件，删掉就好了 0x05 git push 时出现的 Everything up-to-date在git push之前必须要先 git commit -m &quot;&quot; 0x06 Timed out 一般像上面两种报错报错方式，问题在Git 所设端口与系统代理不一致 可以选择关闭http/https网络代理 12git config --global --unset http.proxygit config --global --unset https.proxy 或者重新配置代理 12git config --global http.proxy http://127.0.0.1:自己的端口号git config --global https.proxy http://127.0.0.1:自己的端口号","tags":["Git"],"categories":["踩坑"]},{"title":"MySQL手记","path":"/2023/05/14/230514 MySQL手记/","content":"算是对我入门数据库学习的第一门数据库语言的一个交代了 一、数据库基本命令 SQL语句以英文 ; 为结束符 SQL语句不区分大小写 1.1 基本操作命令 命令 quit / exit / ctrl+d 退出数据库 show databases; 查看所有数据 select database(); 查看当前使用的数据库 create database 数据库名 charset=utf8; 创建数据库 use 数据库名； 使用数据库 drop database 数据库名； 删除数据库-慎重使用 1.2 数据表基本操作命令创建数据表： 12345678910create table 表名(字段名称 数据类型 可选的约束条件field1 datatype constraint1,field2 datatype,field3 datatype,…………………………fieldN datatype,--主键说明可以放在字段中独立说明，也可以放在最后统一说明。primary key(one or more fields)); 12345678create table students(\tid int unsigned primary key auto_increment, --unsigned auto_increment\tname varchar(20) default &#x27;&#x27;,\tage tinyint unsigned default 0, height decimal(5,2), gender enum(&#x27;男&#x27;, &#x27;女&#x27;, &#x27;中性&#x27;,&#x27;保密&#x27;), cls_id int unsigned default 0); Ps： --unsigned无符号、auto_increment表示自动增长 1.3 查看修改表结构命令 查看修改表结构命令 show tables; 查看当前数据库中的所有表 desc 表名; 查看表结构 show create table 表名; 查看表的创建语句–详细过程 在开发过程中不需要频繁的操作表结构，能够在需要的时候根据这些语法写出符合要求的SQL语句就可以啦 数据表结构修改命令 alter table 表名 列名 类型; 添加字段 alter table change 原名 新名 类型及约束; 重命名字段 alter table 表名 modify 列名 类型和约束; 修改字段 alter table 表名 drop 列名; 删除字段 drop table 表名; 删除表 1.4 表数据操作命令 添加数据 1234insert into 表名 values(...); 全列插入:值得顺序与表结构得字段一一对应.insert into 表名(列1,列2...) values(值1,值2,...); 部分列插入:指的顺序与给出得列顺序对应.insert into 表名 values(...),(...)......; 一次性插入多条数据.insert into 表名(列1,列2...) values(值1,值2,...),(值1,值2,...)...; 部分列多行插入数据. 修改查询数据 123select * from 表名; 查询所有列select 列1,列2,列3... from 表名; 查询指定列数据update 表名 set 列1=值1,列2=值2,... where 条件. 修改数据 删除数据 1delete from 表名 where 条件; 删除数据 二、where 比较 运算 查询作用：使用where子句对表中的数据进行筛选 12select * from 表名 where 条件;--select * from students where id=1; 2.1 比较、逻辑运算符1&gt; = &lt; &gt;= &lt;= 不等于!= 或 &lt;&gt; 1and or not 12345678--查询编号大于等于3的女学生:select * from students where id &gt;= 3 and gender=0;--查询姓名不是“BlindArbiter”的学生:select * from students where name != &#x27;BlindArbiter&#x27;;--查询没被删除的学生:select * from students where is_delete=0;--查询年龄不在10岁到15岁之间的学生:select * from students where not (age &gt;= 10 and age &lt;= 15); 2.2 模糊查询关键字：like % 表示任意多个字符 _ 表示一个任意字符 123456--查询students表中姓为张的人:select * from students where name like &quot;张%&quot;;--查询姓张且姓名一共两个字的学生:**select * from students where name like &#x27;张_&#x27;;--查询姓张或叫三的学生:select * from students where name like &#x27;张%&#x27; or name like &#x27;%三&#x27;; 2.3 范围查询 连续范围：in 非连续范围：between……and…… 12--查询编号为3至8的学生：select * from students where id between 3 and 8; 注意：between A and B 在匹配数据的时候匹配的范围空间是 [A,B] 2.4 空判断 null 与 ‘ ’ 是不同的 is not null 顺序不要错误 1234--判断为空: is nullselect * from students where height is null;--判断为非空: is not nullselect * from students where height is not null; 三、order排序查询以百度搜索为例，用户输入关键字搜索，作为网站往往就需要将用户最需要的网页和数据发送给用户，所以百度就会将用户搜索的关键字和数据库中已经存在的数据进行关联性分析，将关联度高的网页准备好发送给用户浏览，但是如果出现很多关联性几乎一致的网页该怎么办呢？ 所以这个时候就需要使用到排序，先将关联程度进行排序，然后将关联程度一样的数据根据比如用户点击量等属性进行排序。 排序查询语法 1select * from 表名 order by 列1 asc|desc (,列2asc|desc,..) 将行数据按列1排序，若列1值相同，则按列2排，以此类推 asc 升序,从小到大（默认） desc 降序,从大到小 1234--查询未删除男生信息，按学号降序:select * from students where gender=1 and is_delete=0 order by id desc;--显示所有的学生信息，先按照年龄从大→小排序，当年龄相同时 按照身高从高→矮排序:select * from students order by age desc,height desc; 四、聚合函数 命令 作用 count(字段) 计算总行数 max(字段) 求此字段得最大值 min(字段) 求此字段得最小值 sum(字段) 求此字段之和 avg(字段) 求此字段平均值 作用：把当前所在表当做一个组进行统计 特点: 每个组函数接收一个参数（字段名或者表达式） 统计结果中默认忽略字段为NULL的记录 不允许出现嵌套 比如sum(max(xx)) 例1：求总行数 1234--返回非NULL数据的总行数.select count(height) from students; --返回总行数，包含null值记录;select count(*) from students; 例2：求最大值 12--查询女生的编号最大值select max(id) from students where gender = 2; 例3：求最小值 12--查询未删除的学生最小编号select min(id) from students where is_delete = 0; 例4：求和 1234--查询男生的总身高select sum(height) from students where gender = 1;--平均身高select sum(height) / count(*) from students where gender = 1; 例5：求平均值 1234--求男生的平均身高, 聚合函数不统计null值，平均身高有误select avg(height) from students where gender = 1;--求男生的平均身高, 包含身高是null的select avg(ifnull(height,0)) from students where gender = 1; 五、group分组查询所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理。 group by 分组 将查询结果按照一个或多个字段分组，字段值相同为一组 1. group by的使用 1234-- 单字段分组：根据gender字段来分组select gender from students group by gender;-- 多字段分组：根据name和gender字段进行分组select name, gender from students group by name, gender; 2. group by + group_concat()的使用 group_concat(字段名): 统计每个分组指定字段的信息集合，每个信息之间使用逗号进行分割 12-- 根据gender字段进行分组，查询gender字段和分组的name字段信息select gender,group_concat(name) from students group by gender; 3. group by + 聚合函数的使用 1234-- 统计不同性别的人的平均年龄select gender,avg(age) from students group by gender;-- 统计不同性别的人的个数select gender,count(*) from students group by gender; 4. group by + having的使用 having作用和where类似都是过滤数据的，但having是过滤分组数据的，只能用于group by 12-- 根据gender字段进行分组，统计分组条数大于2的select gender,count(*) from students group by gender having count(*)&gt;2; 5. group by + with rollup的使用 with rollup的作用是：在最后记录后面新增一行，显示select查询时聚合函数的统计和计算结果 1234-- 根据gender字段进行分组，汇总总人数select gender,count(*) from students group by gender with rollup;-- 根据gender字段进行分组，汇总所有人的年龄select gender,group_concat(age) from students group by gender with rollup; 六、limit限制查询提问：select * from 京东某个数据表，会产生什么效果？ 回答：由于数据过多有可能就直接死机了 limit限制查询 1可以使用limit限制取出记录的数量，但limit要写在sql语句的最后 语法：limit 起始记录，记录数 说明： 起始记录是指从第几条记录开始取，第一条记录得下标是0 记录数是指从起始记录开始向后依次取得记录数 limit (n-1)*m, mn:页数 m: 记录数 例1：查询前3行男生信息: 123select * from students where gender=1 limit 0,3;简写select * from students where gender=1 limit 3; 查询学生表，获取第n页数据的SQL语句: 1select * from students limit (n-1)*m,m 七、连接查询当查询结果的数据来源于多张表时，需要将多张表连接成一个大的数据集进行汇总显示 连接查询 mysql支持三种类型的连接查询，分别为： 内连接查询 外连接查询 自连接查询 7.1 连接查询-内连接 内连接语法 1select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2 例1：使用内连接查询学生表与班级表: 1select * from students as s inner join classes as c on s.cls_id = c.id; 注意: 121 内连接：根据连接条件取出两个表 “交集”2 on 是连接条件 where是连接后筛选条件 7.2 连接查询-外连接 语法 12左连接：主表 left join 从表 on 连接条件;右连接：从表 right join 主表 on 连接条件; 注意 : 能够使用连接的前提是 , 多表之间有字段上的关联 左连接和右连接区别在于主表在SQL语句中的位置, 因此实际左连接就可以满足常见需求 7.2.1 左连接 例1：使用左连接查询学生表与班级表: 1select * from students as s left join classes as c on s.cls_id = c.id; 7.1.2 右连接 例1：使用右连接查询学生表与班级表: 1select * from students as s right join classes as c on s.cls_id = c.id; 7.3 连接查询-自连接就是自己和自己连接的表 创建areas表: 12345create table areas( id varchar(30) not null primary key, title varchar(30), pid varchar(30)); 执行sql文件给areas表导入数据: 12--source 表示执行的sql文件source areas.sql; 自连接查询的用法: 12--自连接查询必须对表起别名 city as c, provice as pselect c.id, c.title, c.pid, p.title from areas as c inner join areas as p on c.pid = p.id where p.title = &#x27;广东省&#x27;; 八、子查询就是把一个查询的结果当做另一查询的条件 标量子查询：子查询返回的结果是一个数据(一行一列) 列子查询：返回的结果是一列(一列多行) 行子查询：返回的结果是一行(一行多列) 主查询和子查询的关系： 子查询是嵌入到主查询中 子查询是辅助主查询的,要么充当条件,要么充当数据源 子查询是可以独立存在的语句,是一条完整的 select 语句 例1. 查询大于平均年龄的学生: 1select * from students where age &gt; (select avg(age) from students); 例2. 查询学生在班的所有班级名字: 1select name from classes where id in (select cls_id from students where cls_id is not null); 例3. 查找年龄最大,身高最高的学生: 1select * from students where (age, height) = (select max(age), max(height) from students); 九、外键 对于已经存在的字段添加外键约束 12-- 为cls_id字段添加外键约束alter table students add foreign key(cls_id) references classes(id); 在创建数据表时设置外键约束 12345678910111213-- 创建学校表create table school( id int not null primary key auto_increment, name varchar(10));-- 创建老师表create table teacher( id int not null primary key auto_increment, name varchar(10), s_id int not null, foreign key(s_id) references school(id)); 外键的作用 外键有一个很重要的作用：防止无效信息的插入注意：外键本身也是一种约束 和 not null 等约束一样 在创建数据表的时候设置外键约束 创建数据表的同时直接创建外键 1234567891011create table goods(\tid int primary key auto_increment not null, name varchar(40) default &#x27;&#x27;, price decimal(5,2), cate_id int unsigned, brand_id int unsigned, in_show bit default 1, is_saleoff bit default 0, foreign key(cate_id) referebces goods_cates(id),\tforeign key(brand_id) referebces goods_brands(id)); 删除外键约束 12345-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称 show create table goods;-- 获取名称之后就可以根据名称来删除外键约束alter table goods drop foreign key 外键名称; 注意:使用到外键约束会极大的降低表更新的效率, 所以在追求读写效率优先的场景下一般很少使用外键 十、一些课堂练习——SQL Service篇写在这里是因为一开始我的SQL Service打不开了，所以就干脆先照着题目写着代码先，找天再另外分开这部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192931．查询新媒体学院学生的学号和姓名。SELECT sno,snameFROM studinfoWHERE sdept = &#x27;新媒体学院&#x27; 2．查询选修了课程的学生学号。 SELECT DISTINCT snoFROM scps:DISTINCT有去重功能3．查询新闻学院或计算机学院姓张的学生信息。SELECT *FROM studinfoWHERE sdept IN (&#x27;新闻学院&#x27;,&#x27;计算机学院&#x27;) AND sname like &#x27;张%&#x27;4．查询其他学院中比“电子信息学院”某一学生年龄小的学生信息。SELECT *FROM studinfoWHERE sbirthday &gt; ANY(SELECT sbirthday FROM studinfo WHERE sdept = &#x27;电子信息学院&#x27;);5．查询选修人数超过10人的课程号。 SELECT cnoFROM scGROUP BY cnoHAVING COUNT(sno)&gt;106．查询每门课的最高分、最低分和平均分。SELECT MAX(score) AS MAX_Score, MIN(score) AS Min_Score, AVG(score) AS AVG_ScoreFROM scGROUP BY cno7．查询选修课平均成绩大于等于85分的学生的学号和其选修课程的最高分。 SELECT studinfo.sno, MAX(sc.score) AS Max_scoreFROM studinfo FULL OUTER JOIN scON studinfo.sno = sc.snoGROUP BY studinfo.snoHAVING AVG(sc.score)&gt;=858．查询选了两门以上的课程的学生姓名。 SELECT studinfo.snameFROM studinfo JOIN scON studinfo.sno = sc.snoGROUP BY studinfo.snameHAVING COUNT(sc.cno)&gt;=29．查询选修“数据库技术与应用”课程且成绩在80分及以上的学生学号和成绩，并要求对查询结果按成绩的降序排列，如果成绩相同则按学号的升序排列。 SELECT studinfo.sno, sc.scoreFROM studinfo JOIN scON studinfo.sno = sc.snoWHERE sc.cno == &#x27;03&#x27; AND sc.score &gt; 80ORDER BY sc.score DESC, studinfo.sno ASC;10．查询学生的学号、姓名、选修的课程名及成绩。 SELECT studinfo.sno,sname,course.cname,sc.scoreFROM studinfo, course, scWHERE studinfo.sno = sc.sno AND course.cno = sc.cno11．查询每一门课的间接先修课信息(即先修课的先修课)。 SELECT *FROM courseWHERE cpno is NOT NULL12. 查询“高等数学”课成绩高于张三“高等数学”课成绩的学生学号和成绩。 SELECT studinfo.sno,sc.scoreFROM sc JOIN studinfo ON studinfo.sno = sc.snoJOIN course ON course.cno = sc.cnoWHERE course.cname = &#x27;高等数学&#x27; AND sc.score &gt; (SELECT score FROM sc JOIN studinfo ON studinfo.sno = sc.sno\tJOIN course ON course.cno = sc.cno WHERE studinfo.sname = &#x27;张三&#x27; AND course.cname = &#x27;高等数学&#x27;)13. 查询每个学生的姓名和选课数量SELECT studinfo.sname, COUNT(sc.cno) AS courseNUMFROM studinfo JOIN scON studinfo.sno = sc.snoGROUP BY studinfo.sname14. 查询学生姓名,所选课程名称和成绩SELECT studinfo.sname,course.cname,sc.scoreFROM scJOIN studinfo ON studinfo.sno = sc.snoJOIN course ON course.cno = sc.cnoSELECT TOP 2 student.sid,sanme,sc.scoreFROM scJOIN student ON sc.sid = student.sidJOIN course ON sc.cid = course.cidWHERE course.","tags":["MySQL"],"categories":["数据库"]},{"title":"Unity在Android中接入SQLite数据库","path":"/2023/03/29/230329 Unity在Android中接入SQLite数据库/","content":"如题，一个新的尝试 第一次参与写一个安卓项目，第一次使用Unity和Android Studio，第一次学习及编写C#脚本，第一次使用SQLite Manager…… 这个项目陆陆续续写了快一个月了，终于收尾了，记录一个踩坑最多、印象最深的板块 Android Studio 连接超时 改URL，改成阿里云的镜像 在Gradle目录下的build.gradle中Google()和jcenter()中间增加 1maven&#123; url ‘http://maven.aliyun.com/nexus/content/groups/public/’&#125; 当时还修改了Project Structure的一些Module属性，比如SDK版本、build Tool版本等，不知道这个有没有影响 创建Unity-安卓工程的密钥文件unity-project setting-player里创建密钥，保存到特定的文件夹里 创建完密钥之后，在下面project Key选择刚才新建的密钥并且填写密码 cmd打开jdk所在的bin文件夹，或者通过配置java/jdk的环境变量再直接cmd 1keytool -genkey -alias 秘钥库名称 -keyalg RSA -validity 有效时间 -keystore 秘钥库文件名 在bin文件生成testuse文件，将其剪切到刚刚创建秘钥的文件夹里 安卓项目调用java脚本 新建一个AS项目，专门用来调试java脚本 切换到Android栏，在app文件夹上创建一个新的module 切换到project时，就可以看到刚刚新建的module 然后在module的src/main/java/com.example.模块名的文件夹里新建一个Java类文件 在这个Java文件里写静态方法 写完方法后，右键文件找到Show in Explorer，就在文件夹中显示这个java文件，复制到unity的project里Assets下新建的Plugins/libs文件夹 SQLite Manager我在Google拓展里用了两个插件，一个是原本的”SQLite Manager”，另一个是”适用于Google Chrome的SQLite Manager”，由于后者的帮助文档我打不开，所以我是结合着两个插件摸索出SQLite语法的。 这就要说说很奇怪的Google SQLite Manager了，它建表有模板，但是它建不成表，它会说无法识别”CREATE”，改过好多次都不行，遇到困难睡大觉 转战SQLite Manager，同样的语法，怎么人家就建出来了，Google SQLite Manager你看看人家 Unity使用SQLite数据库 dll文件和so文件 针对sqlite3：①Mono.Data.Sqlite.dll、②sqlite3.dll 针对发布Android平台：③System.Data.dll、④libsqlite3.so 在Asset/Plugins里加入三个dll，其中①③可在Unity编辑器文件夹\\Editor\\Data\\MonoBleedingEdge\\lib\\mono\\unityjit里复制过去，②在SQLite官网下载，找Precompiled Binaries里相应电脑配置的文件下载，注意从不是Android版本 在Asset/Plugins/里创建Android文件夹，把libsqlite3.so放其中 dll和so的配置 Mono.Data.Sqlite.dll 和 sqlite3.dll：Any Platform System.Data.dll 和 libsqlite3.so：Android 都只勾选Android，因为PC环境不需要，勾选全平台的话会报错 libsqlite.so文件还要在下面的Platform settings选择ARMv7 更改完记得应用插件 Load at Startup 将建好的数据库文件放入Asset/StreamingAssets里 C# 使用命名空间using Mono.Data.Sqlite写代码即可 注意Android端需要拷贝数据库文件在我写完调用数据库代码并且真机调试时，我发现在unity上可以正常使用的登录系统，在安卓端上无法正常运行😢 这其实是因为：移动端是不能读写StreamingAssets路径下的文件的，但是会打包到安装包中，所以我们要把StreamingAssets中的数据库拷贝到持久化PersistentDataPath路径中 看到说可以用WWW类复制数据库文件，好的开始学习写完脚本之后，unity给我报错说WWW已经过期了，建议使用WebRequest😅 好的开始重新学习语法又被弃用了，无所谓，这个简单，换一下就好了 C# —跟SQLite数据库相关部分 using Mono.Data.Sqlite; 开头声明使用模块 主要使用的数据库三个类 SqliteConnection：创建与特定数据库的连接 SqliteCommand：针对数据库执行SQL语句 SqliteDataReader：从数据源读取数据流 连接数据库 12345678910111213private SqliteConnection con;private SqliteCommand command;private void DataBaseInit()&#123; //数据库路径字符串,注意最后的文件要改成自己的数据库文件名 path = &quot;Data Source = &quot; + Application.streamingAssetsPath + &quot;/users.db&quot;; //实例化连接对象 con = new SqliteConnection(path); //打开数据库文件 con.Open(); //创建指令对象 command = con.CreateCommand();&#125; 使用数据库指令 12//command.CommandText = &quot;SQL指令&quot;command.CommandText = &quot;Select * From users Where name=&#x27;&quot;+ UserInput.text+&quot;&#x27;&quot;; 接受、更新数据 ExecuteScalar() 只返回一个值，主要用来接收数据，如返回的密码 ExecuteNonQuery() 主要用来更新数据，通常使于执行Update、Insert和Delete语句 存档、删档 12PlayerPrefs.SetString(&quot;数据名&quot;, 数据);PlayerPrefs.DeleteAll(); WebRequest using UnityEngine.Networking; 创建连接 12var uri = new System.Uri(地址);UnityWebRequest www =UnityWebRequest.Get(uri); 获取传输的文本 1www.downloadHandler.text 打包安卓apk文件在打包之前可以把手机跟电脑用数据线连上，不然就会报这样的错误😅 用的小米手机，一开始找不到手机里的开发者模式，没关系我会变魔术设置-我的设备-全部参数：点击MIUI五次就可以进入开发者模式，设置里也会多了开发者模式选项 一定要打开USB调试还有USB安装，不然会给你拦截😮 之后打开Build Setting，先把Run Device刷新之后改成自己的安卓设备，在下方找Export选择一个安装调试文件的路径，注意这个路径不要含有中文，等安装好之后就可以点击旁边的Bulid and Run安装到手机里了 很奇怪的是，这个打包我就成功了一次之后，想着做完修改了删掉apk再重新打包的时候，unity显示的是打包成功，安卓设备上也显示连接上问我是否安装，但是apk却安装不到我的手机上😢 无所谓，我会换一台安卓设备测试的时候，没有删除第一次打包的再安装一个新的也是OK的，尝试让其他兄弟给我打个包让我试试装装，就有了这段报错，应该是因为我们这是个协作项目，我在unity的签名跟给我打这个包的兄弟不同，所以失败。 Unity其他报错成就收集栏目笑死了，对于刚接触unity的新手来说，就是见一个报错一个新鲜，跟成就收集似的🧐报错太多了，我也筛一筛，像什么脚本语法错误之类的我是没脸放上来的🤥，记一些显得比较有含金量或者比较有意思的报错。 Loading assembly failed: “Assets/Plugins/Mono.Data.Sqlite.dll” reason: File does not contain a valid CIL image 应该是导入的dll和unity内部编译器的target版本应该有差异，从网上下载dll文件也仅仅是适用于分享者的文件，最好还是按照上面讲过的路径，Unity编辑器下的Editor\\Data\\MonoBleedingEdge\\lib\\mono\\unityjit SqliteException: SQLite error no such table 这个问题应该是C#写数据库路径文件名没写对，或者是streamingAsset文件夹里没有数据库文件 1path = &quot;Data Source = &quot; + Application.streamingAssetsPath + &quot;/unity_users.db&quot;; 连踩两坑😶 一次是文件后缀名写成了.sqlite，导致后来运行脚本的时候，Unity给我新建了一个unity_users.sqlite文件，当时我以为是Unity给我自动配置的文件所以没有管😓，我反思，不该不管的 第二次是改对了路径之后运行，给我报我的文件不是数据库的错误（别问为什么没有截图，问就是忘了）是的，我给忘记了，我只接触过MySQL，所以当时用的就是MySQL写的数据库文件，但是我用的SQLite接的Unity，（其实在报错之前我都还觉得MySQL和SQLite没什么区别）所以无非两个选择，一个是重新写C#脚本，改用MySQL接，另一个是写一个SQLite数据库文件。当然选择容易实现一点的，不就是学一下用SQLite Manager😴。 Sqlite Error: SQLite error no such column在插入数据到数据库时，注意Varchar类型的，在传入数据的时候要插入引号 1&quot;&#x27;&quot; + 你要插入的数据 + &quot;&#x27;&quot; error CS0234：The type or namespace name“xxx“does not exist in the namespace“yyy“打包的时候报的错，我记得我当时吧Project Settings/Player/Android/Other Settings/Configuration/Api Compatibility Level*的.Net文件换成另外一个就好了 新奇的乱码错误(?)这么清新脱俗的报错一定不是我这种刚接触unity的废物能看懂的对吧，不记得改了哪步导致的，无所谓，我会选择不保存然后重开😴","tags":["Unity","Android","SQLite"],"categories":["数据库"]},{"title":"MySQL注册表迁移和两种服务模式的切换","path":"/2023/03/25/230325 MySQL的迁移和两种连接服务/","content":"二战MySQL 故事背景是我在MySQL里建立的数据库不能和data文件夹同步，这可能是我的MySQL走的网络服务连接，也可能是my.ini配置文件没写明白，总之我把MySQL切换到本地服务连接模式之后就能同步了。所以试试切换成数据库本地连接，刚好因为C盘空间真的不够，想着说顺便一块将MySQL迁移到别的盘。 修改MySQL及数据存放位置C盘空间不足人必修课之一 停止mysql服务 本地服务：net stop mysql 网络服务：本地控制面板/管理工具/服务，或者win+r输入services.msc，找到mysql服务右键停止 其实本地服务和网络服务都可以在服务面板里打开或停止 转移数据文件，换盘放 修改新地址文件中的my.ini文件 主要改这两条，改成新地址 12basedir=E:\\lenovo\\MySQL\\MySQL Server 8.0datadir=E:\\lenovo\\MySQL\\MySQL Server 8.0\\data 修改注册服务 cmd输入regedit进入注册表编辑器 打开HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/MySQL文件夹 选择ImagePath，指定所修改的my.ini位置 比如我的新地址是–defaults-file=”E:\\lenovo\\MySQL\\MySQL Server 8.0\\my.ini” 服务启动 本地服务：net start mysql 网络服务：服务面板打开mysql网络服务 查看数据库文件存储位置由于我当时要接入数据库信息，但是找不到文件在哪，这个时候可以在mysql里输入下面命令，会返回位置：(这个时候我还是网络服务连接的数据库) 1show global variables like &quot;%datadir%&quot;; Data目录初始化打开mysql文件夹发现，我的文件夹里根本没有Data文件夹😶 没有？那就初始化目录一下 用管理员的身份在终端念出下面的咒语，如果没有报错的话，data文件夹就会现身了 12mysqld --initializemysqld --no-defaults --initialize` 启动MySQL本地系统连接服务123mysqld -install //注册net start mysql //启动net stop mysql //停止 去查了一下，大部分说的是my.ini配置文件没写明白，可是问题来了，我的mysql8根目录下找不到my.ini文件😶 试过一些方法，还是找不到my.ini（后来知道了怎么勾选查看隐藏文件，不过无所谓，我会新建文件覆盖），我自己建一个my.ini，然后再试试： 好的，直接被拒绝😢 MySQL有分本地系统连接和网络服务连接，大胆推测应该是只能使用一种连接方式连接(?) 我上面的失败是建立在我已经连接了网络服务之后的，在我关闭了网络服务的mysql80之后，就能连接上了 用管理员身份打开终端输入 1mysqld --initialize --console 我根据使用命令之后返回的信息，修改了my.ini文件，然后粉碎掉旧data文件，再重复执行上面的命令，直到不报错，出现A temporary password is generated for root@localhost:xxx 这个是本地系统给你设定的mysql处初始随机密码，一定要记下来！（不然一直密码错误无法登录mysql） 之后mysql -uroot -p随机密码，诶，连上了！ 一些踩坑ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.连上mysql之后，测试使用mysql命令的时候又双叒叕给我报错了，OK这题我会，因为是给的是初始随机密码，所以肯定要设置一个新密码 1set password=&#x27;你的新密码&#x27;; ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost:3306’ (10061) 见过好几次这个报错，我推测这个报错应该就是没接上mysql服务(?) 上面第一张图应该是昨天连接数据库太频繁了，给我卡住了，连不上(?) 第二张是今天特地重启了一次电脑才开始连接，就莫名其妙地，成功了 ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES)这个大概率是密码问题，这条报错最后面写（using password：NO）的话就是没输入密码(using password: YES)大概率就是密码错误了 主要是之前我一直用的网络连接，现在转成了本地连接，没想到系统会给我初始随机密码，所以我就是一直输入旧密码一直报错😢 ERROR MySQL服务启动后停止 这个大概就是昨天操作太频繁了，我一会连接一会又停止它，它大概是不开心了，给我发黄牌警告呢🤐 总结就是重启大法好。 my.ini配置文件比较多的说法是可以从mysql文件夹里点开查看部分，勾选查看隐藏的项目就能看到my,ini文件，但是我当时没找到，所以是新建my.ini文件覆盖旧文件来解决的问题 我用的是mysql8，根据mysqld --initialize --console返回的信息修改了我原本的my.ini文件 提一些需要注意的点： 1234567891011121314151617181920[mysqld]port=3306# 设置mysql的安装目录及data数据存放目录，注意这里要修改成自己mysql的路径及想要存放data的路径basedir=E:\\lenovo\\MySQL\\MySQL Server 8.0datadir=E:\\lenovo\\MySQL\\MySQL Server 8.0\\data# 旧的服务端使用的字符集为utf8(utfmb3),新版本及未来版本为utf8mb4character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# default_authentication_plugin 功能已弃用; default_authentication_plugin=mysql_native_password# --ssl=off 也弃用了,新版本可以用下面的语句代替;--tls-version=invalid[mysql]# 设置mysql客户端默认字符集，同理default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8mb4","tags":["MySQL"],"categories":["数据库"]},{"title":"JavaScript—基础","path":"/2023/03/18/230318 JavaScript基础/","content":"之前为了找bug浅浅地接触一下的JS JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言。被广泛的应用于Web开发。 写JavaScript的位置： 页面script标签 &lt;script&gt;js代码&lt;/script&gt; （推荐）&lt;script language=&quot;javascript&quot;&gt;js代码&lt;/script&gt; js脚本没有固定位置 外部脚本引入（推荐） 创建：xxx.js引入：&lt;script src=&quot;路径/xxx.js&quot;&gt;&lt;/script&gt; 标签属性中（不常用，不推荐） &lt;div onclick=&quot;js代码&quot;&gt;&lt;/div&gt; 一、变量声明123var x = 10; //不做声明的时候默认var，重复定义会覆盖，存在变量覆盖变量污染问题。(不推荐)let y = 10; //使用let关键词定义一个变量x，重复定义会报错。(常用)const z = 10; //const定义的变量一般不做修改 可一次定义一个或多个变量 变量定义后，若没有赋值，那么变量会被赋予一个初始值——undefined（未定义） 变量的命名规范: 可以使用数字、字母、下划线(_)、美元符号($)的组合，且不能以数字开头 严格区分大小写（比如 A 和 a 不是同一个变量） 不能使用保留字或关键字 二、输出2.1 console.log()； 可以在浏览器的控制台输出信息，便于调试程序 2.2 日志 在浏览器控制台中打印日志。一般用来做代码调试。 12345console.log(&#x27;普通日志&#x27;);console.error(&#x27;报错日志&#x27;);console.warn(&#x27;警告日志&#x27;);console.dir(console); //输出对象的日志console.timelog(new Date()); //时间日志 2.3 弹窗 根据浏览器不同弹窗框样式不一样且无法修改样式 alert() 普通弹窗。一般用来做代码调试 confirm() 确认弹窗，有确认和取消两个选择。配合赋值可以得到用户的选择 prompt() 输入弹窗，有输入框可以输入文字。配合赋值可以得到用户输入的内容 三、数据类型 检测和转换类型函数 typeof()：检测数据的类型 Number()、 String()、 Boolean() ：转换数据类型 parseInt() parseFloat() ：取整数或者浮点数。 3.1 Number类型JavaScript不区分整数、浮点数等，统一都叫Number。typeof 100 得到 &quot;number&quot;。 浮点数精度问题 JS数值的运行会先将数值转为二进制，这种标准下小数可能会表示不全，导致最终的结果出现误差。 为了得到相对准确的结果，一般会将小数转为整数之后再进行运行，最后除以倍数。举个🌰: 12console.log( 0.1111+0.2222 ); //0.33330000000000004console.log( (0.1111*10000+0.2222*10000)/10000 ); //0.3333 JavaScript 中的 Number 类型只能表示[ -(253 - 1) , (253 -1)] 之间的数值。 Number 类型中还有一些比较特殊的： Infinity：表示正无穷大的数值 -Infinity：表示负无穷大的数值 NaN：(Not a Number)即非数值，用来表示无效或未定义的数学运算结构，如 0 除以 0 3.2 String类型 三种引号都能表示str 1&quot;文字&quot; &#x27;str&#x27; `abcd` 转义字符 12console.log( &quot;I&#x27;m a cool guy.&quot; ); //一种引号里面可以使用其他两种引号console.log( &quot;I said,\\&quot;Hello World.\\&quot;&quot; ); //引号内部使用相同的引号，则需要使用 \\ 转义符号 字符串拼接 进行 + 运算时，两边任意一边的数据是字符串的话，则是拼接的功能 12console.log(&quot;123&quot; + &quot;4&quot;); //&quot;1234&quot;console.log(&quot;123&quot; + 4); //&quot;1234&quot; 3.3 Boolean类型布尔类只有两个值：真true 假false。用于判断。注意：在python里首字母要用大写：True False 3.4 Undefined类型未定义类型的值为undefined在变量没有被赋值时，默认值也为undefined。 3.5 Null类型null和undefined意义很接近，都表示“没有”。null可以理解为一个“空”对象，但并不占据内存空间。通常在一个变量即将在后续的逻辑中被赋予一个对象值，但刚开始定义的时候不能确定到底是哪个对象值时，赋予它初始值null。 注意：typeof null得到&quot;object&quot;。 3.6 Object类型JS中object类型包含数组、普通对象、DOM节点、内置对象、函数等等 3.6.1 数组 取值用 [数字序号] 下标，从0开始计数，数组中可以存放数组。取值超出最大值时，得到undefined 12345let arr = [10,[&quot;Blind&quot;,&quot;Arbiter&quot;,[true,false]]];console.log(arr[0]); //10console.log(arr[1][0]); //&quot;Blind&quot;console.log(arr[2][1]); //falseconsole.log(arr[4]); //undefined 数组拥有 length 属性，可以得到数组存放的数据的个数。 1234let a = [1,2];let b = [3,4,,5,];console.log(a.length); //2console.log(b.length); //4 最后面没有值的话，不算个数，中间的,,之间即使没有数据也算个数 修改值或者新增删除值 123456789101112131415161718192021//指定下标式修改、新增数据let arr1 = [1,2];arr1[0] = 111;arr1[2] = 3;console.log(arr1); // [111,2,3]//通过设定数组长度删除值let arr2 = [7,8,9];arr2.length = 2;console.log(arr2); //[7,8]//增arr.unshift(&#x27;001&#x27;); //加在最前arr.pull(&#x27;100&#x27;); //加在末尾arr.splice(指定下标,往后删除数据个数,&quot;增加的数据1&quot;,&quot;数据2&quot;...); //指定位置加入//删arr.shift(); //头arr.pop(); //尾arr.splice(指定下标,往后删除数据个数); //指定//清空数组arr = []arr = null 3.6.2 普通对象 对象以键值对形式存储数据。键=对象属性，值=具体数据。 属性的命名规则比变量更宽松。属性名允许是数字，不规范的属性名字可以加&quot; &quot;变成一个正确的属性名。 取值时使用 . 操作符。 12345678910let a = &#123; name : &quot;BlindArbiter&quot;, &quot;age&quot; : 10000, //属性可以加 &quot;&quot; 类似字符串的写法，也可以不加 &quot;a b c&quot; : true, //不规则的属性名，必须加 &quot;&quot;，不加会报错 20 : null //自然数数字可以充当属性名，不必加 &quot;&quot; friend : [&quot;张三&quot;，&quot;李四&quot;]&#125;;console.log( a.age ); //10000console.log( a.friends[0] ); //&quot;张三&quot;console.log( a.hobby ); //undefined 当属性是一个数据时，使用 [] 来取值 123let a = &quot;age&quot;;console.log( xz[a] ); //18console.log( xz.a ); //undefined 对象可以取值，也可以重新赋值，也可以新增属性 12345let obj = &#123;a : 10&#125;;obj.a = 20;obj.b = 30;console.log(obj); //&#123;a:20,b:30&#125; 3.6.3 函数 函数是一个极为特殊的对象。 定义函数并执行 123456789101112//定义函数let a = function()&#123; //js代码&#125;;function b()&#123; //js代码 return 返回值&#125;//执行函数a(); b();//函数不调用则不执行 匿名函数 12345678//定义匿名函数function()&#123;&#125;//定义箭头函数(也是匿名函数的一种)() =&gt;&#123; //js代码&#125;//执行(()=&gt;&#123;&#125;)() object类型的数据，typeof会得到object，但是函数在typeof时得到function 四、运算符4.1 算术运算符 + 不同情景的不同作用： 123let a = 1 + 2; //结果:3 算术运算let b = 1 + &quot;2&quot;; //结果:&quot;12&quot; 拼接运算，+号两边任一边有字符串，+号就是拼接的作用let c = +&quot;1&quot;; //结果:1 +号前面没有数据，类似Number()功能，将数据转换为数字，转不了得到NaN - 不同情景的不同作用： 1234let a = 2 - 1; //结果1 算术运算let b = &quot;2&quot; - 1; //结果1 当成数字来运算let c = -1; //结果-1 负号let d = -&quot;1&quot;; //结果-1 同+号前面都没有时情况一样，只不过最终结果带上 负号 - ++ -- 前置后置自增自减 (同C) 1234let x = 3;console.log(x++); //3 //此时x=3+1=4 //可以理解为先赋值再运算console.log(++x); //5 //可以理解为先运算再赋值// ++/-- 就是 +1/-1 4.2 隐式类型转换不同类型的数据进行运算时会进行隐式类型转换： 1234567//num和str进行+运算时，会转换成str再运算 1 +&quot;2&quot; === &quot;12&quot; //进行减、乘、除、取模、乘方运算时，会先转换成数字再运算&quot;3&quot;-&quot;2&quot; === 1//++、--运算会先转换成数字再自增自减，最后得到数字结果let x = &quot;3&quot;;x++; 4.3 赋值运算符1= += -= *= /= %= x += 10; 相当于 x = x+10; ，其他同理，不多说。 注意：, 可表示在一条语句里面执行多个事情 1let x = (1,2,3,4,5); //x值最终为5 4.4 比较运算符1== === != !=== &gt; &lt; &gt;= &lt;= 运算后得到布尔值。==判断值等不等，===判断值和类型等不等。 字符串比较大小时，是按位比较各自的编码。&quot;5&quot;&gt;&quot;20&quot;得到true。 对象在进行相等判断时，比较的是内存地址。 4.5 逻辑运算符1&amp;&amp; || ! 与或非，!的结果始终是一个布尔值。 4.6 三目运算符1条件表达式 ? 表达式1 : 表达式2 ; 条件成立执行表达式1，不成立则2 五、判断、循环js里基本判断语句和基本循环语句的格式同C，直接过，这里不多讲了 5.1 判断 选择 if else if else 123456789101112if( 条件1 )&#123; //条件1为真时执行的代码&#125;else if( 条件2 )&#123; //条件1假 条件2真时执行的代码&#125;else&#123; //条件1、2都不满足时执行的代码&#125; switch 1234567891011121314switch(a)&#123; case &quot;1&quot;: //code1 break; case &quot;2&quot;: //code2 break; case &quot;3&quot;: //code3 break; default: //code4 break;&#125; 5.2 循环 js的for循环，我愿称之为C+Python的结合版 123for(语句1; 语句2; 语句3)&#123;\t//循环code&#125; while 1234567while( 条件 )&#123;\t//循环code&#125;do&#123; //循环code&#125;while( 条件 ) 还有，终止整个循环的break、终止单次循环的continue 5.3 数组循环 for遍历对象 1234a=&#123;1&#125;for(const key in a)&#123; console.log(key, a[key]); //key value //a[key]表示可变的值&#125; forEach()方法 1234567const arr1 = [33,44,55];let arr2=[11,22];arr1.forEach(function(value)&#123; arr2.push(value)&#125;)arr2.forEach((内容,下标)=&gt;&#123; console.log(内容,下标)&#125;) //根据本人多次尝试发现，forEach只传一个非纯数字参数的时候只输出内容，两个任意非等非纯数字参数时则输出内容和下标 map() 映射：把一个原数组映射成对应的新数组 1234let arr1 = [1,2,3,4]let arr2 = arr1.map(function(value)&#123; return value*value&#125;) 六、字符串、数组常用方法6.1 字符串方法 length 字符串长度，只能读取不可修改 charAt() 获取某一个字符串项，可以代替[ ]下标获取 substring() 截取字符串 1234567let str = &quot;HelloWorld&quot;console.log(str.length)//获取字符串中的某个数据console.log(str[1]) //econsole.log(str.charAt(1))//e//参数1为起始位置(包含)，参数2结束位置(不包含)，参数2不写默认截取所有console.log(str.substring(1,4)) //ell charCodeAt() 返回指定位置的字符串unicode编码 String.fromCharCode() 通过unicode编码返回对应的字符 123let str = &quot;JavaScript&quot;console.log(str.charCodeAt(2)) //118console.log(String.fromCharCode(11097)) //⭙ 字符串.toUpperCase() 大写转小写（不接受参数） 字符串.toLowerCase() 小写转大写（不接受参数） split() 切割字符串变数组（同python） 12let str = &quot;hello world&quot;console.log(str.split(&quot;&quot;)) //[&#x27;hello&#x27;,&#x27;world&#x27;] 6.2 数组方法 length 数组长度，不同于字符串的是数组长度可读可修改 1234567let arr = [1,2,3,4]console.log(arr.length) //4//数组长度可改变，数组内容也发生改变arr.length = 2console.log(arr) //[1,2] arr.length = 6 //数组长度增加 对应空数组项是undefinedconsole.log(arr[5]) //undefined //获取数组的某一数据 push() 依次往数组后面添加数组项 pop() 删除数组最后一项 12345let arr = [1,2,3]let arr1 = arr.push(4,5)console.log(arr) //[1,2,3,4,5]let arr1 = arr.pop()console.log(arr) //[1,2,3,4] shift() 移除数组第一项，同时数组长度-1 unshift() 在数组前添加一项数据 12345let arr = [1,2,3]let arr1 = arr.shift()console.log(arr) //[2,3]let arr1 = arr.unshift(0)console.log(arr) // [0,2,3] splice(index,num,info) index 从第几个项开始 num 往后删除几个数组项 info 从删除位置开始添加数组项 12345678910111213let arr = [1,2,3,4,5]arr.splice(2,3,&quot;a&quot;,&quot;b&quot;)console.log(arr) //[1,2,&quot;a&quot;,&quot;b&quot;]//1.=push() let arr = [1,2,3,4]arr.splice(arr.length,0,5) //[1,2,3,4,5]//2.=pop()arr.splice(arr.length-1,1) //[1,2,3,4]//3.=shift()arr.splice(0,1) //[2,3,4]//4.=unshift()arr.splice(0,0,5) //[5, 2, 3, 4] sort() 数组排列 接受一个函数作为参数，函数有两个形参 12345let arr = [22,44,11,33,55]arr.sort(function(a,b)&#123; return a - b //从小到大排列 return b - a //从大到小排列&#125;) concat() 合并两个数组为一个新的数组 123let arr1 = [1,2]let arr2 = [&quot;a&quot;,&quot;b&quot;]console.log(arr1.concat(arr2)) //[1, 2, &#x27;a&#x27;, &#x27;b&#x27;] join() 根据参数规则返回新的字符串，不改变原数组 123let arr = [1,2,3,4]let arr1 = arr.join(&quot;-&quot;)console.log(arr1) //1-2-3-4 isArray() 判断接受的对象是否是数组，因为如果直接用typeof检测数组将返回object 12let arr = [1,2,3]console.log(Array.isArray(arr)) //true 6.3 字符串和数组两者通用方法 indexOf() 顺序检索 lastIndexOf() 倒序检索 123456//只有一个参数,返回下标let str=&quot;hello&quot;console.log(str.indexOf(&quot;e&quot;)) //1console.log(str.lastIndexOf(&quot;e&quot;)) //1//两个参数：参数1是检索值，参数2表示从什么位置开始检索，没有将返回-1console.log(str.indexOf(&quot;o&quot;,1)) //4 七、基础DOM操作DOM（Document Object Model）文档对象模型。规定了一些用于操作HTML页面的API。 API（Application Programming Interface，应用程序接口）是一些预先定义的，已经拥有某些功能的函数或属性。我们可以直接按照自己的需求来使用。 7.1 获取页面元素JS中要操作HTML标签，得先获取到对应的标签，我们称之为元素或者节点对象。 通过选择器获取（推荐） 12document.querySelector(&quot;#main .nav&quot;);document.querySelectorAll(&quot;#banner li&quot;); //获取多个 //或者可以理解为选中同一种标签 通过ID获取（推荐） 1document.getElementById(&quot;main&quot;) 通过class名获取 1document.getElementsByClassName(&quot;left&quot;) 通过标签名获取 1document.getElementsByTagName(&quot;p&quot;) 特殊标签的获取 获取html标签 document.documentElement 获取head标签 document.head 获取body标签 document.body 获取title标签 document.title 7.2 创建、添加、删除节点 创建节点 123createElement() //创建一个元素节点createTextNode() //创建一个文本节点createDocumentFragment() //创建一个文档碎片，先将多个节点整合到这里面再统一添加 添加节点 12appendChild() //在元素最后添加一个子节点insertBefore(a,b) //在元素某个子节点之前添加新子节点，参数a为新节点，参数b为已存在的子节点 替换节点 1replaceChild(a,b) //用新节点替换某个子节点，参数a为新节点，参数b为已存在的某个子节点 删除节点 1removeChild() //删除元素的某个子节点 演示效果代码块这是什么链接？点一下传送门123456789101112131415161718192021&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script&gt; //获取 let test = document.querySelector(&#x27;#test&#x27;);\tconsole.log(test); //创建 let h3 = document.createElement(&quot;h3&quot;); let a = document.createElement(&quot;a&quot;); //插入内容 h3.innerText=&#x27;这是什么链接？点一下&#x27;; a.innerText = &#x27;传送门&#x27;; a.href = &#x27;https://github.com/BlindArbiter&#x27;; console.log(a); //添加 test.appendChild(h3); test.appendChild(a);\t//删除\t//test.removeChild(h3)&lt;/script&gt; 7.3 监听事件 事件种类 鼠标事件 onclick左键单击、 ondblclick左键双击、oncontextmenu右键单击、 onmouseover onmouseenter鼠标移入 、onmouseout onmouseleave鼠标移出、、 onmousedown鼠标按下、 onmousmove鼠标移动 、onmouseup鼠标抬起 键盘事件 onkeydown onkeypress 键按下、 onkeyup键抬起 系统事件 onload加载完成后、 onerror加载出错后、 onresize窗口调整大小时 、onscroll滚动时 表单事件 onfocus获取焦点后 、onblur失去焦点后、 onchange改变内容后 、onreset重置后、 onselect选择后 、onsubmit提交后 监听事件写法 DOM节点.on事件 = 函数()&#123; code &#125; 这里的函数称之为事件函数，它不会自执行，而是当事件触发时才执行。 操作HTML内容 DOM节点.innerHTML 获取/修改 元素的HTML内容DOM节点.innerText 获取/修改 元素的文本内容 this 在事件函数中， this 表示触发事件的这个节点对象，可以类比一下C++的this指针。 八、属性操作、样式操作8.1 操作样式 修改样式 JS想要改变元素的样式，那么就相当于要改变控制元素的css（三种样式 ）： 外部样式 ：前端的JS不能修改一个外部的文件，所以无法直接修改外部样式来改变元素。 内部样式：内部样式放置到style标签中，而style又在当前页面中，所以能被JS控制。(麻烦，不推荐) 行内样式：直接写在标签中，并且优先级最高。(最常用) 节点.style.属性 来控制单个的行内样式。 节点.style.cssText 来控制节点的所有行内样式。 Tip：当单个标签操作的样式比较多时，直接改变class来改变样式会方便很多。 获取样式 .style 只能获取行内样式，要获取元素的最终显示样式使用 getComputedStyle(节点)。 8.2 操作class名字使用 .className 可以来操作标签的类名，但是需要新加一个类名，或者去掉某个类名时，使用.className较为麻烦。所以推荐使用新API.classList 来操作类名。 添加：节点.classList.add(&quot;类名&quot;) 移除：节点.classList.remove(&quot;类名&quot;) 切换（有则删，无则加）：节点.classList.toggle(&quot;类名&quot;) 判断是否有某个类名（得到布尔值）：节点.classList.contain(&quot;类名&quot;)","tags":["JS"],"categories":["Web开发"]},{"title":"HTML—CSS","path":"/2023/03/05/230305 HTML-css/","content":"我们一般用css来改变样式，实现样式和结构相分离 css代码分为外部样式、内部样式、行内样式三种写法。 外部样式（推荐👍） 单独创建.css后缀的文件，通过link标签引入，link通常放置于头部： rel表示link标签的类型，值为’stylesheet’时起到牵线搭桥的作用 1&lt;link rel=&#x27;stylesheet&#x27; href=&#x27;路径&#x27;&gt; 内部样式 通过style标签写在HTML内部，利用选择器选择，样式设置 行内样式 直接写在标签属性中 123&lt;body&gt; &lt;p style=&quot;css代码&quot;&gt;这里是一些段落文字&lt;/p&gt;&lt;/body&gt; 选择器写在&lt;style&gt; &lt;/style&gt;里，可以把它理解为中间商(?) id与class命名 id命名唯一，单个标签不允许多个id名，同页面中不存出现重复的id名，重名会影响js代码获取标签 class命名不唯一，单个标签可以拥有多个class名，不同标签允许使用相同class名 注意一些命名规范 允许大小写字母和数字，必须以字母开头，单词一般小写； 见名知意，不允许单个字母做名字，各命名词汇英文参考：命名词汇 单词之间使用-号连词或者驼峰连词（具体看目标网页或者具体公司的整体规范） 选择器分类 基础选择器 写法 举例 通配符选择器（指所有标签） * *&#123; margin:0; padding:0; &#125; 标签选择器 标签名 div&#123; width:50px; height:50px; &#125; class类选择器 .class类名 .nav&#123; width:20px; &#125; id选择器 #id名 #id1&#123; width:50px; &#125; 复合选择器 写法 举例 后代选择器（非固定父子关系） 父 子 孙… .nav div a&#123; margin:10px; &#125; 子代选择器（只会选取儿子） 父 &gt; 子 div&gt;a&#123; color:red; &#125; 组合选择器（多选择器同一样式） 选择器 , 选择器 .nav p,#id1 a&#123; font-size: 12px; &#125; 伪类选择器 写法 举例 链接伪类（鼠标悬停） :hover a:hover&#123;color:red;&#125; 链接伪类（鼠标点击选中） :active p:active&#123;color:blue;&#125; 表单获得焦点时被选中 :focus input:focus &#123;background-color: green; &#125; 选择器权重问题来了，如果一个标签被多个选择器赋予了相同的属性且值不一样时，这个标签在网页会显示哪种属性🤔 举个例子🌰：此时.nav和p都选中了这个p标签，且规定了不同颜色 123/*css代码文件*/.nav&#123;color: red;&#125;p&#123;color: blue;&#125; 12&lt;!--HTML代码文件--&gt;&lt;p class=&quot;nav&quot;&gt;这是一段文字&lt;/p&gt; 这里就出来一个概念：选择器权重，顾名思义，这句文本最终颜色就要根据选择器的优先级决定。 !important可标识该选择器最高权重 123p&#123; color:red !important&#125; 选择器权重：!important &gt; id &gt; class类|伪类 &gt; 标签 &gt; 通配符 &gt; 继承样式 先比较权重，权重一样比较各级别选择器出现的次数 当多个选择器权重一样时，以最后出现的为准 盒子模型在HTML中，标签都是一个长方形模型，每一个html标签都可以看成一个盒子 盒子模型包含内容区(content)、内边距(padding)、边框(border)、外边距(margin) 在开发者模式中可以看到该网页的盒子模型 内容区content见名知意，即放置内容（或者说标签） 其大小可由盒子中的内容撑开，或者设置 width height 属性来指定固定的大小。 px是一种像素单位 12345div&#123; width: 100px; height: 100px; background-color: red; /*在开发的时候或许可以先添加着背景色便于观察(?)*/&#125; 一个小建议：在布局时，除非迫不得已，任何盒子不要设定死高度，由着盒子内容自己把盒子撑大就好啦 内边距padding盒子内容和边框的距离 padding属性接收长度值或百分比值，但不接收负值： 123456 div&#123; padding-top: 10px; /*上内边距*/ padding-right: 10px; /*右内边距*/ padding-bottom: 5px; /*下内边距*/ padding-left: 5px; /*左内边距*/&#125; padding属性可用一个属性表示四个方位的值，看接收值个数： 1234567891011/*1、上下左右 全部10px*/div&#123; padding: 10px; &#125;/*2、上下10px、左右20px*/div&#123; padding: 10px 20px; &#125;/*3、上10px、左右20px、下30px*/div&#123; padding: 10px 20px 30px; &#125;/*4、上10px、右20px、下30px、左40px*/div&#123; padding: 10px 20px 30px 40px; &#125; 边框border可由统一的border属性来规定边框，这三个值顺序可以打乱： 12/*border: border-width、border-style、border-color */div&#123; border: 5px solid red; &#125; 也可分解属性表示： 123456div&#123; border-top: 10px solid red; border-right: 5px solid red; border-bottom: 10px solid red; border-left: 5px solid red;&#125; 还可以进一步分解为border-width、border-style、border-color 123456789101112/*1.全部方位*/div&#123; border-width: 5px; border-style: solid; border-color: red;&#125;/*2、单个方位*/div&#123; border-top-width: 4px; border-top-style: solid; border-top-color: red;&#125; 边框线常用类型 值 描述 none 无边框 solid 实线 dotted 点状边框 dashed 虚线 double 双线（宽度=border-width的值） 外边距margin盒子和盒子之间的距离 margin属性的值和padding很类似，不过margin允许负值 margin的左右还多了auto值，可以用来将盒子在父级中自动居中 怪异盒子模型上面说的盒子模型就是标准盒形象地说的话，如果说标准盒是个外向的喜欢向外分享的小盒子，那么怪异盒就是个内向的小盒子(?)🤔 怪异盒子的width和height都=content + border + padding怪异盒模型下盒子大小 = width (content + border + padding) + margin 其实就是当我们设置一个怪异盒及其大小时，如果后面调整了border或者padding的大小，那么content部分大小会随之自动调整，整个盒子不会膨胀 设置怪异盒子： 1box-sizing: border-box 字体文本样式字体样式 属性 作用 备注 color 字体颜色 font-size 字体大小 单位px font-weight 字体粗细 normal正常 blod粗 bolder更粗 lighter更细 (或者100-900整百数数值) font-famliy 字体名称 font-style 字体样式 normal正常 italic 斜体 line-height 行高 normal默认合理的行间距 / 数值大小=行间距 复合写法 1234567/*font: 斜体 粗细 字体大小/行高 字体类型; */&lt;style&gt; body &#123; font: italic 700 16px/normal &#x27;HarmonyOS_Regular&#x27; &#125;&lt;/style&gt; 字体大小和行高必须用/合在一起，不能分开； 字体大小和字体类型必写，除此之外省略某些项也不会影响后面其它属性。 文本样式 水平对齐方式 text-align text-align： left 居左对齐 center 居中对齐 right 居右对齐 justify 两端对齐 大小写 text-transform text-transform： none 默认值 uppercase 全部转化大写 lowercase 全部转化小写 capitalize 首字母转换为大写 文本线 text-decoration text-decoration： none 没有文本线 underline 下划线 line-through 中划线 overline 上划线 text-decoration-color: 划线颜色 text-decoration-style:划线转态 dotted点状线、dashed 虚线、solid 实线、double 双边框、wavy：波浪线 其他属性 属性 作用 备注 overflow 文本溢出显示方式 auto显示滚动条 hidden隐藏 text-indent 首行缩进 带单位的长度值（px / em） letter-spacing 字间距 word-spacing 单词间距 white-space 换行方式 normal默认正常换行 nowrap文本不换行 word-break 长单词换行方式 normal默认换行方式break-all允许在单词内换行 keep-all只能在半角空格或连字符处换行 user-select 选中设置 auto自由选择 none不能选择 all全部选中 背景属性background是一个复合属性，用于设置盒子的背景颜色或背景图片。 复合写法： 1backgorund: color image repeat position/size attachment; 背景颜色background-color背景色默认是会延伸到border下方的 12background-color: 颜色;&lt;!--默认 transparent透明--&gt; 背景图片background-image背景图片默认也是会延伸到border下方的 1234/*1、默认不插入背景图*/div&#123; background-image: none; &#125;/*2、插入背景图 */div&#123; background-image: url(&quot;路径&quot;); &#125; 背景与内容的层叠关系如图： 背景平铺background-repeat1div&#123; background-repeat: 值; &#125; 值 repeat 默认背景图片平铺 no-repeat 背景图片不平铺 repeat-x 背景图片水平平铺 repeat-y 背景图片垂直平铺 图片位置background-position1background-position:X Y; X Y 默认0 0, 取值可以是像素px或者百分比%X Y 还可以取的值：X：left左对齐、center水平居中、right右对齐Y：top顶部对齐、center垂直居中、bottom底部对齐 如果只给一个值，那么另一个值默认center（50%） 图片尺寸background-size通常用于在不改变图片宽高比的情况下，铺满盒子。 background-size: X Y X Y值默认对应原图 宽 高 cover 等比例缩放直到铺满X轴和Y轴 contain 等比例缩放直到铺满X或Y轴其中一个 背景附着background-attachment background-attachment: scroll 默认，背景随滚动而滚动 fixed 背景不随滚动而滚动 背景图片和img标签的对比 背景图片不占用content内容部分，而img标签会占用。 背景图片大小如果超出盒子不会显示，而img标签如果超出父级盒子默认是会超出显示的。 背景图片：给盒子内容部分加背景，或者加一些小图标项目符号等img标签：具体想表达的一个图片信息、希望搜索引擎能检索到对应的图片信息 一些补充圆角边框border-radius取值通常为像素px或者百分比 1234/*全部角：*/border-radius: 10%;/*分解单个角*/border-top-left-radius: 10px 30px; 复合写法： border-radius： 一个值 10px 全部角 两个值 10px 20px 左上右下 || 右上左下 三个值 10px 20px 30px 左上 || 右上左下 || 右下 四个值 10px 20px 30px 40px 左上 || 右上|| 右下 || 左下 阴影box-shadow盒子阴影，让盒子四周产生阴影； 1234567891011div&#123; box-shadow:10px 5px 10px 5px red outset;&#125;/*值1：水平偏移（必需）值2：垂直偏移（必需）值3：模糊距离（可选，默认0） 从扩散边缘开始，向外逐渐模糊的距离值4：扩散距离（可选，默认0） 规则从何处开始模糊，默认0即盒子边，大于0则会看到阴影明显漏出，允许负值值5：隐藏颜色（可选，默认黑色）值6：阴影扩散方向（可选，默认ouset向外扩展，可以改为inset向内扩展）*/ 透明 opacity取值 0—1（完全透明——完全不透明） 渐变色 线性渐变 12/*百分比值也可以用确却的像素值代替*/background: linear-gradient(red 100%, blue 0%); 鼠标样式cursor属性规定鼠标移入元素时的样式 值 描述 url 自定义光标的URL。(请在此列表的末端始终定义一种普通光标，以防没有由URL定义的可用光标。) default 默认光标（通常是一个箭头） auto 默认值。浏览器设置的光标。 crosshair 光标呈现为十字线。 pointer 光标呈现为指示链接的指针（一只手） move 此光标指示某对象可被移动。 text 此光标指示文本。 wait 此光标指示程序正忙（通常是一只表或沙漏）。 help 此光标指示可用的帮助（通常是一个问号或一个气球）。 定位position属性，可以将元素从文档流中取出，然后使用方位词（left top right bottom）精准控制它的位置。不同的定位值可以使元素拥有不同的表现形式，例如放在另外一个元素上面或者固定在浏览器的显示区某个位置。 值 描述 relative 生成相对定位的元素，相对于其正常位置进行定位。 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 相对定位 relative 相对于原有位置的定位，通过方位属性进行相对于原位置的偏移。 （定位元素才有的方位属性： top | bottom | left | right，值一般使用px单位或%值。） 特点： 不脱离文档流 不影响元素本身的任何特性 如果不加方位词偏移也没有任何影响 绝对定位 absolute 能让元素脱离文档流 (原地起飞…(?))，使用方位属性相对于最近的有定位的父级元素进行偏移； 注意！方位属性初始值不是0，而是auto。 left和top优先级比right和bottom高，比如一个元素既拥有left也拥有right，最终位置以left为准。 特点： 脱离文档流 元素宽高默认值为0 上级盒子中得有一个盒子作为载体，找不到最近的定位父级则相对于body标签 会将元素转换成块元素 设置了绝对定位，没有设置层级；html后写居上 margin:auto 会暂时失效 fixed 固定定位能让元素脱离文档流，使用方位属性相对于浏览器可视区进行偏移； 特点： 脱离文档流 元素宽高默认值为0 margin:auto 会失效 层级🌰问题又来了，定位元素之间，可能会出现覆盖问题，定位元素会遮挡住另一个定位元素 那么当然是越后面出现的元素优先级越高，我们可以使用z-index层级属性来调整优先级。 z-index属性只针对定位元素有效 取值为一个整数数字，默认auto，可正可负","tags":["HTML"],"categories":["Web开发"]},{"title":"HTML-基础","path":"/2023/03/02/230302 HTML-基础/","content":"关于前端web开发的正经笔记，这篇是不含css的HTML基础 一、网页基础知识1.1 HTML模板新建或者打开一个.html文件，输入!后按空格会出现一个模板 123456789101112131415&lt;!DOCTYPE html&gt; &lt;!--规定了浏览器文档使用哪种规范，以前需要在后面写上很长一串规范地址，现今HTML5规范无须额外指定--&gt;&lt;html lang=&quot;zh-cn&quot;&gt; &lt;!--所有网页最大的结构 网页中所有的标签存放在html标签中--&gt; &lt;head&gt; &lt;!--网页头部 网页设置 告诉浏览器一些相关信息--&gt; &lt;!--meta 具体设置网页设置的标签 --&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!--网页编码格式 推荐UTF-8国际编码,常用的还有gbk国标--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!--视口 -→ 移动端--&gt; &lt;title&gt;我是网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页主体 网页结构 &lt;/body&gt;&lt;/html&gt; 1.2 HTML的lang属性 决定浏览器是否自动弹出翻译框 弹出: en，代表是英文网页(不管后续写的内容是不是英文) 不弹出: zh-cn，代表网页是一个中文网页 1.3 注意一些书写规范 标签、属性名以及相关符号书写均在英文半角状态下的小写 id、class必须以字母开头 所有双标签必须闭合 属性值必须带引号，单双引号都可以 二、标签2.1 meta (辅助标签)meta标签写在head标签中，具体设置网页设置的标签 2.2 div (块标签) (division分开分隔) 独占一行（上下分割） 2.3 H系列标题标签(heading) h1~h6标签用于表示网页内容的标题，不同程度的加粗与增大。 在一个网页中**h1标签最好是有且仅有一个**（有利于SEO优化） 2.4 排序标签 2.4.1 ul无序列表标签 (unordered list不排序的列表) 其子标签必须是&lt;li&gt;。 默认实心圆点符号，修改type属性可改变符号 1234567891011&lt;!--type=&quot;disc&quot; 实心圆点type=&quot;circle&quot; 空心圆点type=&quot;square&quot; 实心方块type=&quot;none&quot; 不显示符号--&gt;&lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;第一行&lt;/li&gt; &lt;li&gt;第二行&lt;/li&gt; &lt;li&gt;第三行&lt;/li&gt;&lt;/ul&gt; 2.4.2 ol有序列表标签 (ordered list有序表) 其子标签必须是&lt;li&gt;。 默认有数字符号，修改type属性可改变符号 12345678910&lt;!--type=&quot;1&quot; 数字顺序type=&quot;A&quot; 或者 type=&quot;a&quot; 字母顺序type=&quot;I&quot; 或者 type=&quot;i&quot; 罗马数字顺序--&gt;&lt;ol type=&quot;A&quot;&gt; &lt;li&gt;第一点&lt;/li&gt; &lt;li&gt;第二点&lt;/li&gt; &lt;li&gt;第三点&lt;/li&gt;&lt;/ol&gt; 2.5 p段落标签 (paragraph)12&lt;p&gt; p标签中通常用来放置一段文字。 注意：p标签里不可以放div标签(任意块标签)，这会导致在浏览器中p标签会被分隔成两个。&lt;/p&gt; 2.6 a标签 (超链接 / 锚点) 2.6.1 超链接 通过添加target属性可以指定打开链接的位置 target=”_blank” 新标签页打开 target=”_new” 新标签页打开，但所有的new只会打开一个新标签页 target=”_self” 默认，在当前标签页打开 1&lt;a href=&quot;https://blindarbiter.github.io&quot; target=&quot;_blank&quot;&gt;点我跳转到BlindArbiter的博客&lt;/a&gt; 2.6.2 锚点 (anchor锚) 跳到页面中的对应位置，锚点还可配合name属性使用 12&lt;a href=&quot;#abc&quot;&gt;点我页面滚动到name为abc的标签位置&gt;&lt;/a&gt;&lt;a name=&quot;abc&quot;&gt;滚到这里&lt;/a&gt; 2.7 img标签 (image图像)单标签，可用 / 作为结尾 12&lt;img src=&quot;xxx&quot;&gt;&lt;img src=&quot;xxx&quot; /&gt; 两种写法都可以在HTML5的新标准中，明确的指出了不需要/来结束单标签，所以，更推荐大家不写/ 一些常用属性： src：指定图片资源路径 相对路径：或者直接以文件名或目录名开头。 ./ 相当于当前路径 ../ 返回到该文件的上一级路径 绝对路径：一个从根目录出发的路径或者一个完整的网络地址。 / 项目根目录 所有写路径的地方都适用相对路径和绝对路径的写法，比如上面讲过的a标签herf属性。 width height：指定img显示大小 能为img图片预留对应的空间从而不影响其他布局 1234&lt;img src=&quot;xxx&quot; width=&quot;200px&quot; height=&quot;100px&quot;&gt; 像素单位px&lt;img src=&quot;xxx&quot; width=&quot;50vw&quot; height=&quot;50vh&quot;&gt; 可视区域的单位view width/height：1vh=1%屏幕占比 tip：width与height一般情况下和图片原始尺寸保持一致，不过不一致也是允许的，但即使使用width和height缩小图片，仅仅是视觉上的缩小，浏览器还是需要加载原始的图片资源（并不能减轻请求压力）,所以有图片缩放的需求时，应当提前用图片处理软件处理好了之后，再引入图片。 alt属性：告知搜索引擎当前图片表示 当img的src地址出错时，alt属性的值能显示出来（或许能让用户/浏览者得到不那么糟糕的体验(?)） 123&lt;imghref=&quot;https://github.com/BlindArbiter/BlindArbiter.github.io/blob/master/img/hexo_blog/cover1.jpg&quot; alt=&quot;烟花&quot; title ：在img标签里，当鼠标指针移动到图片上时，title能够显示出提示文字（增强用户/浏览者体验） tip：仅限于网络图片打不开，当别人做了安全验证时way：在我们要用图片的html页面的head中，加入以下代码（解除限制） 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt; 2.8 其他标签一些与内容同化的标签 标签名称 写法 b标签 &lt;b&gt;&lt;/b&gt; 文字加粗，strong还能够被搜索引擎检索 i标签em标签 &lt;i&gt;&lt;/i&gt;&lt;em&gt;&lt;/em&gt; 文字斜体，i标签仅为视觉上斜体em还能被搜索引擎检索 br标签 &lt;br/&gt; 文本换行 hr标签 &lt;hr&gt; 横线分隔 sup标签sub标签 &lt;sub&gt;&lt;/sub&gt;&lt;sup&gt;&lt;/sup&gt; 上角标下角标。 del标签 &lt;del&gt;&lt;/del&gt; 删除线 span标签 &lt;span&gt;&lt;/span&gt; 本身没有特殊效果，可配合css添加样式 1&lt;span style=&#x27;color:red&#x27;&gt;红色&lt;/span&gt; 三、表格table双标签 &lt;table&gt;&lt;/table&gt; tr 定义表格的行，内容都写在行里面 th (thead) 行里面，字体加粗，表示头部标题 td (tbody) 行里面，表示表格具体每一项 12345678&lt;table&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;td&gt;表格内容&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 3.1 边框和边距属性 属性 / 样式 作用 border 每个单元格都加上边框（但该数值大小只影响外围边框粗细） cellpadding 单元格内容与边框的距离 cellspacing 单元格之间间隙大小 align 设置文字对齐方式（类似于text-align） border-collapse:collapse(css样式) 相邻单元格的边框合并（style=’ ‘/用选择器） css样式的style行内样式写法 12345&lt;style&gt;table&#123;\tborder-collapse:collapse;\t&#125;&lt;/style&gt; css样式选择器写法 123456&lt;table style=&quot;border-collapse:collapse&quot;&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 3.2 单元格合并纵向合并：rowspan 规定单元格纵跨的行数 1&lt;td rowspan=&quot;2&quot;&gt;&lt;/td&gt; 横向合并：colspan 规定单元格横跨的列数 1&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt; tip：合并后记得删除多余单元格 其它补充： tbody 即使不写，默认也会添加这个标签去包裹所有内容； caption 表格标题 四、表单由表单域、表单控件和提示信息组成作用：收集客户端信息 4.1 form标签form标签是一个存储表单元素的区域，里面提供数据输入和采集的是很多表单控件元素完成的。 写法 123&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; target=&quot;打开方式&quot; name=&quot;表单名&quot;&gt; &lt;!--各种表单控件元素--&gt;&lt;/form&gt; action — 表单提交地址 method — 表单提交数据的方式（get 和 post） target — 打开方式 即后端返回的新页面 (同上述a标签的target) name — 表单名 4.2 表单控件 属性 type 表单类型 name 赋值属性 value 设置表单控件的值 placeholder 提示文本 checked 默认选择，单选或多选时，可以指定初始默认的已被选中的项 disabled 禁止使用，规定input禁止使用 hidden 隐藏视图 表单控件的作用是采集用户的数据然后提交到后端，所有的控件都必须有name及value属性，并且除了单选多选外，所有的控件name都不能相同。 input单标签，标签属性type不同，意义不同： value的值随便定义，后面添加文字补充说明 空按钮一般用js添加功能事件 属性 示例 text 单行文本框 &lt;input type=&quot;text&quot; name=&quot;名字&quot; placeholder=&quot;提示文字&quot; /&gt; password 密码输入框 &lt;input type=&quot;password&quot; name=&quot;名字&quot; /&gt; radio 单选按钮 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 checkbox 多项选择 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot; /&gt;羽毛球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot; /&gt;乒乓球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot; /&gt;网球 button 空按钮 &lt;input type=&quot;button&quot; value=&quot;按钮&quot; /&gt; &lt;button type=&quot;button&quot;&gt;按钮&lt;/button&gt; reset 重置按钮 &lt;input type=&quot;reset&quot; /&gt; file 上传文件 &lt;input type=&quot;file&quot; name=&quot;f&quot; /&gt; hidden 隐藏 &lt;input type=&quot;hidden&quot; name=&quot;hide&quot; value=&quot;1&quot; /&gt; submit 提交 &lt;input type=&quot;submit&quot; /&gt;&lt;button&gt;提交按钮&lt;/button&gt; number 数字输入框 &lt;input type=&quot;number&quot; /&gt; (min最小 max最大 step倍数) range 数字滑块 &lt;input type=&quot;range&quot; /&gt; (min最小 max最大 step倍数) timedatemonthweek 时间年月日年月年周 &lt;input type=&quot;time&quot; /&gt; &lt;input type=&quot;date&quot; /&gt;&lt;input type=&quot;month&quot; /&gt; &lt;input type=&quot;week&quot; /&gt; color 颜色 &lt;input type=&quot;color&quot; /&gt; label辅助input进行选择。 我们可以通过给文字加上label标签然后将文字和input关联起来。 一个label只服务一个表单控件 123456label的for属性与input的id属性对应：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; id=&quot;sex1&quot; /&gt;&lt;label for=&quot;sex1&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;2&quot; id=&quot;sex2&quot; /&gt;&lt;label for=&quot;sex2&quot;&gt;女&lt;/label&gt;或者：&lt;label&gt; &lt;input type=&quot;radio&quot;,name=&quot;sex&quot;，value=&quot;男&quot;&gt;男 &lt;/label&gt;&lt;label&gt; &lt;input type=&quot;radio&quot;,name=&quot;sex&quot;，value=&quot;女&quot;&gt;女 &lt;/label&gt; 下拉选框select 和 option配合实现下拉选框 1234567891011&lt;!-- name规定给select value规定给option并且不能相同 --&gt;&lt;select name=&quot;days&quot;&gt; &lt;option value=&quot;none&quot;&gt;---请选择星期---&lt;/option&gt; &lt;!--或 value=&quot;&quot; --&gt; &lt;option value=&quot;1&quot;&gt;星期一&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;星期二&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;星期三&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;星期四&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;星期五&lt;/option&gt; &lt;option value=&quot;6&quot;&gt;星期六&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;星期日&lt;/option&gt;&lt;/select&gt; select标签的size属性：规定下拉时最多显示几个 option标签的selected属性：规定默认显示哪个option 文本域textarea多行文本输入框，rows标签属性定义高度，cols标签属性定义宽度； 如果需要用来传值，同样的需要制定name属性。 表单控件分组fieldset 和 legend配合将多个表单控件根据需要分组； fieldset分组，legend定义组标题。 12345678910111213&lt;form action=&quot;&quot; medthod=&quot;&quot; name=&quot;&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;注册信息&lt;/legend&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; 密 码：&lt;input type=&quot;text&quot; name=&quot;pwd&quot; /&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;个人信息&lt;/legend&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; /&gt;女 &lt;/fieldset&gt;&lt;/form&gt; 4.3 一些补充表单相关选择器 :focus 表单获得焦点时被选中。 :focus-within 表单自身或者表单后代元素焦点时被选中触发","tags":["HTML"],"categories":["Web开发"]},{"title":"搭博客不完整实录2","path":"/2023/02/26/230226 搭博客不完整实录2/","content":"我随便记记，你随便看看 记一些踩坑，记一些修改，慢慢研究慢慢学学，一点一点搭起这个小破站 Template rander error报错难得整理完一篇博客想着发布完收工，好的传不上😐 报错如图 先去查看了官方文档，是这么说的🤔 有时在运行命令$ hexo generate时返回一个错误: 一个可能的原因是文件中有一些无法识别的单词，例如不可见的零宽度字符。 小小小小小小小小小插曲： 看到 “文件中出现“这里，🤔 说来好笑，对，我非常老实地去检查了上面列出来的一个个文件，然后发现这些文件全都是搭博客那天随着主题一起下载的文件，修改日期都是同一天同一个时候，我想着之前更新博客时也没报错，怎么现在更新博客却会报错，应该不是这些文件的问题。 对，想得真好，但是我一身反骨。本着认真严谨的质疑精神和怀疑态度，花了几天学习了下JavaScript，当我能看懂这些文件的大概之后，我又沉默了，因为文件真的没问题，是我有问题🤐 于是向万能的互联网屈服了 回到正题： 这是在发布文章时会出现的一种错误可能是在文章中使用了大括号 &#123; &#125; 这个特殊字符，且没有转义导致编译不通过（至少我是） 解决办法就是，先找到出现问题的文章，再对&#123;&#125;进行转义 或者 删掉其中的&#123;&#125; FATAL: Could not read from remote repository. 使用hexo d命令时报的生成错误。 打开git 1234567git init删除博客文件下.deploy_git文件git push origin master //切换成master分支git config --global core.autocrlf falsehexo clhexo ghexo d 还创建了一个公钥（虽然感觉应该不是这个公钥的作用，但既然做了这步也还是记一记） 1ssh-keygen -t rsa -C “github用户名@github.com” 图片由于新建的博客看着实在太空了，于是就想着推篇文章充实充实 本地浏览看的时候就发现图片全都被施展了消失魔法😕 原md文件插入的图片和html格式不兼容 可以把第三条Typora里自带的图片插入的绝对路径改为相对路径（即第一条，注意\\要改成/） 也可以用img标签格式，属性src=&#39;指定图片资源路径&#39;（第二条）还有width、height、alt、title等属性，不过我一般都懒得调整就是了 区别如图： 总之就是typora里能看到的图片一般都放不上网页，看不见的没写错格式和路径的一般都行👏 还有放的封面图片，横幅图片等同理。 要想本地看到图片blog也能看到，没问题，我们只需要把图上传到github，然后把图片路径改成github里图片的url就好啦🥳，这样可以不用考虑那么多标准，我每次发博客都会提前改掉图片路径，一块传完上去就都能看到啦（墙裂推荐👍） 迁移—RSS首先，安装 hexo-migrator-rss 插件。 1$ npm install hexo-migrator-rss --save 插件安装完成后，执行下列命令，从RSS迁移所有文章。source 可以是文件路径或网址。 1$ hexo migrate rss &lt;source&gt; （这个功能我还在摸索） Footer页脚链接带下划线，可以去主题的\\source\\css\\_layout\\sidebar\\footer.styl里面找到a.item在里面添加或修改text-decoration属性： 1text-decoration: none 字体要想引用外部字体，你需要先在 _config.yml 中 inject 引入 举例，这里换的是HarmonyOS 字体 在_config.yml里插入 12345inject: head: - &lt;link rel=&quot;preconnect&quot; href=&quot;https://s1.hdslb.com/&quot; /&gt; - &lt;link rel=&quot;stylesheet&quot; href=&quot;//s1.hdslb.com/bfs/static/jinkela/long/font/regular.css&quot; media=&quot;all&quot; onload=&quot;this.media=&#x27;all&#x27;&quot; /&gt; - &lt;link rel=&quot;stylesheet&quot; href=&quot;//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css&quot; media=&quot;all&quot; onload=&quot;this.media=&#x27;all&#x27;&quot; /&gt; 修改主题文件 /source/css/_custom.styl对应行： 1$ff-body = HarmonyOS_Regular 修改主题配置文件style/font-family： 123body: HarmonyOS_Regular喜欢粗一点的可以：body: sHarmonyOS_Medium 添加背景动态线条效果在/layout/layout.ejs 的&lt;body&gt;里添加代码 123&lt;script type=&quot;text/javascript&quot; color=&quot;220,220,220&quot; opacity=&#x27;0.7&#x27; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; color：线条颜色(R,G,B)，默认：(0,0,0) opacity：线条透明度(0~1)，默认：0.5 zIndex：用于控制所在层的位置，默认：-1 count：线条总数量，默认：150","tags":["hexo"],"categories":["踩坑"]},{"title":"搭博客不完整实录1","path":"/2023/02/24/230224 搭博客不完整实录1/","content":"我随便记记，你随便看看 一、搭建前的准备 github新建仓库，命名为自己的名字.github.io Initialize那里Add.gitgnore template:Node 安装Node.js： http://nodejs.cn/download/ 安装Git：https://git-scm.com/ 安装cnpm：换淘宝镜像源 123456-- $ npm install -g cnpm --registry=https://registry.npm.taobao.org-- 后面重装系统时发现上面这条已经过时了，用下面这条来安装cnpm$ npm install -g cnpm --registry=http://registry.npmmirror.com-- 检查 cnpm 安装，输出版本号即安装成功：$ cnpm -v 二、安装hexo和搭建博客hexo中文文档 安装hexo-cli 1npm install -g hexo-cli 一开始在git上下载了一个不靠谱的hexo-cli包，里面只有一个压缩包，手动解压之后发现它的bin目录下居然没有hexo.cmd的文件😢！！！后来换npm重新下载了一个。 hexo网页配置 然后把hexo.cmd添加到环境变量里，再hexo init 另外，就是在终端输入hexo，有INFO字样的时候才说明配置成功 配置完成后找一个位置 123hexo init (初始化博客)hexo init blog (会在对应文件夹下面生成blog包)nmp install (安装依赖到node_modules) ssh连接到GitHub这一步是让GitHub上生成的网页与hexo同步 cmd 里生成公钥 1ssh-keygen.exe 在 git 里打开 .ssh里有的公钥文件 以及查看公钥 12$ ls ~/.ssh$ cat ~/.ssh/[公钥文件名].pub 将得到的公钥复制到github—settings—SSH and GPG keys 来添加密钥 生成网页 可以偷懒写简写噢 123hexo generate / hexo g 生成网站静态文件到默认设置的public文件夹hexo server / hexo s 启动本地服务器hexo deploy / hexo d 将生成的网站静态文件部署到设定的仓库 先输入前两条，结尾会有一个网址http://localhost:4000 （这个是本地的默认网页）(可用浏览器浏览) 因为 hexo d 默认上传master分支，而在GitHub默认main分支 所以在输入第三条hexo d命令前，先改一下。 还有settings-brances这里，如果是main的话也改成master 改完就直接hexo d✌ 别问为什么没有成功后的截图，问就是生成网站之后太兴奋了所以忘记了截 然后改改配置改改网址，之后输入网址之后就可以看到自己的博客了✌✌ 这个repo的地址在GitHub项目里 三、更换主题 找个喜欢的主题先，可以去hexo主题商店看看 可以用git clone将主题克隆到themes/里 1git clone 主题的仓库网址.git themes/主题名字 全局配置文件_config.yml里修改theme：新主题 在博客目录下新建主题配置文件_config.主题名.yml，然后把新下载的主题文件的配置文件复制进去 1hexo cl &amp; hexo g &amp; hexo s 再进入http://localhost:4000就可以看或更换完主题之后的效果 tip：每次运行hexo g 、hexo s之前可以用hexo clean清除一下缓存 不同的主题其实配置属性什么的还是有很多差异的，就各自找各自主题作者的说明文件还有源码好好磨一下好啦 四、其他问题放着其他问题是因为，我忘记这个问题出现在什么位置了 cmd提示找不到hexo-deployer-git的话，那就安装一个吧： 1npm install hexo-deployer-git --save","tags":["hexo"],"categories":["踩坑"]},{"title":"关于","path":"/about/index.html","content":"感谢相遇，不论结局 友链动态Modifier美丽废物Drunkbaby小酌一壶GhDemi今晚一定早睡2023 年 6 月 8 日HAPPY BIRTHDAY！2023 年 2 月 26 日时间线，测试完毕，over2023 年 2 月 20 日感谢相遇！"},{"title":"友链","path":"/friends/index.html","content":"感谢相遇，不论结局 Modifier美丽废物Drunkbaby小酌一壶GhDemi今晚一定早睡"},{"title":"朋友文章","path":"/friends/rss/index.html","content":""},{"title":"便笺","path":"/notes/index.html","content":"动态随记收藏"},{"path":"/wiki/notes/index.html","content":"​—title:便笺layout:wikiwiki:Notessitemap:falsebreadcrumb:falseorder:0​— 该页面出去打工了，忙完就会回来了"},{"title":"收藏","path":"/notes/collect/index.html","content":"GeoGebra数学"},{"title":"动态","path":"/notes/essay/index.html","content":"2023 年 6 月 8 日HAPPY BIRTHDAY！2023 年 2 月 26 日时间线，测试完毕，over2023 年 2 月 20 日感谢相遇！"},{"title":"漂流瓶","path":"/notes/essay/write.html","content":"存放一些我腐朽又溃烂的思想和灵魂 230604 与人辩论一则最近有人问我感觉自己是属于理性的还是感性的，我当时直接就回复说我说不了，因为连我自己都不能断言自己是什么样的人。后来我们就这个话题谈论了一番。理性还是感性，我认为没有绝对的范畴，有的人更偏向感性，有的人更偏向理性，也有的人在这件事上理性这件事上感性。理性还是感性，我觉得可以说是，一种人们给自己和他人贴上的标签或者评价。虽然从小到现在任何一个时期都被要求写着什么自我评价他人评价，但其实我并不喜欢写这些，一直都觉得没必要给自己和他人设置那么多的评价和标签，这些词句堆砌出来的只是一个简单的形象轮廓，并不一定是我自己。我想我经历的所有，是没有办法用寥寥几个词几句话轻描淡写地说完的。再说词句的褒贬是相对的，它们是不能，或者说不足以概括我的。当然并不是说标签评价不能存在，只是至少不应该让这些束缚住自己。我是复杂的我，我可以有很多可能，我也没有义务做一年前，一天前，甚至是一分钟前的自己。我一直觉得人不能用自己不能决定的东西定义，比方说性别、相貌、家庭、国籍等，我听过太多这样评价，理智上我是不愿接受的，情感上有时却会被煽动。我知道很多刻板印象就是这么带来的，但没有办法让人们都保持理智冷静独立思考的能力，就算可以，但只要有人在的地方，矛盾分歧争议还是免不了的吧。或许最多期望可以少一点吧。所以如果说非要让我认真地去评价一个人，我更愿意用这个人做过的事，说过的话去评价。"}]